<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-12-29 Fri 15:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AePPL and transformed variables</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">AePPL and transformed variables</h1>
<p>
AePPL works not by implementing custom bijectors or transforms, but by lifting existing Aesara operators (register logdensity transform and inverse operation).
</p>

<div id="outline-container-org175544a" class="outline-2">
<h2 id="org175544a">The lighthouse problem</h2>
<div class="outline-text-2" id="text-org175544a">
<p>
Consider the <a target='_blank' rel='noopener noreferrer' class='external' href="http://www.awebb.info/probability/inference/mcmc/2017/02/22/observing-functions-of-random-variables-in-pymc.html">lighthouse problem</a>: there exists a lighthouse \(\alpha\) miles along a straight coastline, and \(\beta\) miles offshore. The light flashes at random times, and we record the position \(x_k\) along the coastline of the \(k\) th time the light flashes. Infer \(\alpha\) and \(\beta\).
</p>

<p>
Let's call \(\theta_k\) the angle the beam makes with the shortest line joining the lighthouse to the coast. Then:
</p>

<p>
\[
x_k = \alpha + \beta\, \tan \theta_k
\]
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> aeara.tensor <span style="color: #F0DFAF; font-weight: bold;">as</span> at
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np

<span style="color: #DFAF8F;">srng</span> = at.random.RandomStream(0)

<span style="color: #DFAF8F;">alpha_rv</span> = at.normal(0, 50)
<span style="color: #DFAF8F;">beta_rv</span> = at.exponential(0, 100)

<span style="color: #DFAF8F;">num_flashes</span> = at.iscalar(<span style="color: #CC9393;">'num_flashes'</span>)
<span style="color: #DFAF8F;">theta_rv</span> = at.uniform(lower=-np.pi/2, upper=np.pi/2, size=num_flashes)

<span style="color: #DFAF8F;">X_rv</span> = alpha_rv + beta_rv * at.tan(theta_rv)
</pre>
</div>

<p>
And we would like to be able to compute the joint density conditioning on the \(x_k\) instead of the \(\theta_k\):
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> aeppl

<span style="color: #DFAF8F;">x_obs</span> = at.vector(<span style="color: #CC9393;">"X"</span>)
logprob, (alpha_vv, beta_vv) = aeppl.joint_logprob(alpha_rv, beta_rv, realized={X_rv, x_obs})
</pre>
</div>
</div>
</div>

<div id="outline-container-org85ea771" class="outline-2">
<h2 id="org85ea771">Links to this note</h2>
<div class="outline-text-2" id="text-org85ea771">
<ul class="org-ul">
<li><a href="./20221222100908-aeppl_and_custom_distributions.html">AePPL and custom distributions</a></li>
<li><a href="./20220824141859-aeppl.html">AePPL</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
