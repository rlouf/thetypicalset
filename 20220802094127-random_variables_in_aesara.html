<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-10-11 Tue 16:47 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Random Variables in Aesara</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Random Variables in Aesara</h1>
<ul class="org-ul">
<li><code>RandomGenerator</code></li>
<li><code>RandomState</code></li>
<li><code>RandomStream</code></li>
</ul>

<div id="outline-container-org861996c" class="outline-2">
<h2 id="org861996c">AeP (Aesara Enhancement Propoal)</h2>
<div class="outline-text-2" id="text-org861996c">
</div>
<div id="outline-container-org63b8c6e" class="outline-3">
<h3 id="org63b8c6e">Guidelines</h3>
<div class="outline-text-3" id="text-org63b8c6e">
<p>
A good PRNG design satisfies the following conditions:
</p>
<ol class="org-ol">
<li>It is <b><b>expressive</b></b>: the behavior of the system is <b><b>predictable</b></b> by the caller, and allows them to expression any probabilistic program;</li>
<li>It makes it possible to build <b><b>reproducible</b></b> programs ("seeding");</li>
<li>It is <b><b>explicit in Aesara's IR</b></b></li>
<li>It can be manipulated by <b><b>Aesara's rewrite system</b></b>;</li>
<li>It can be <b>easily transpiled</b> to current backends;</li>
<li>It enables <b><b>vectorization</b></b> with generalized universal functions;</li>
</ol>
</div>
</div>

<div id="outline-container-org83b9e98" class="outline-3">
<h3 id="org83b9e98">Limits of the current design</h3>
<div class="outline-text-3" id="text-org83b9e98">
<p>
The current <code>RandomState</code> model threads the RNG state through all the functions that generate random values. This is how the <code>RandomState</code> API would look like with <code>default_output</code> set to <code>None</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">sample</span>(rng):

<span style="font-weight: bold; font-style: italic;">rng</span> = np.random.default_rng(12)
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(0, 1, rng=rng)
<span style="font-weight: bold; font-style: italic;">rng_y</span>, <span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(0, 1, rng=rng_x)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
This design is inconvenient to work with.
</p>
</div>

<ul class="org-ul">
<li><a id="org88a248e"></a>Error-prone and cumbersome<br />
<div class="outline-text-5" id="text-org88a248e">
<p>
<b>For users</b> having to explictly thread the <code>rng</code> states is both error-prone and cumbersome. I believe this is why the RNG output is hidden by setting <code>default_output</code> to <code>1</code>, and one of the motivations behind the <code>RandomStream</code> interface.
</p>
</div>
</li>

<li><a id="org9593c79"></a>Adds sequencing constraints between functions that have no data dependence<br />
<div class="outline-text-5" id="text-org9593c79">
<p>
<b>For the Aesara IR</b> the threading of RNGs adds sequencing constraints between functions that have no data dependence otherwise. In theory, the two calls to <code>at.random.normal</code> are independent and could be made in parallel. In practice, one has to wait for the first call to complete to be able to make the second all.
</p>

<p>
Same with gufuncs: we do not want to introduce rng-dependence between the different function calls. We want to be able to give each dimension (give example) a rng and let it run with it. No collision:
</p>
</div>
</li>

<li><a id="org458634d"></a>Lack of a clear symbolic representation<br />
<div class="outline-text-5" id="text-org458634d">
<p>
<b>For the Aesara IR</b> we don't have distinct operators that updates the random state and generate a pseudo-random number from a random state.
</p>

<p>
And finally this is not enought for the one-to-many problem in rewrites.
</p>

<p>
Only the caller knows how the random state should be managed as called functions are unaware of the context. The solution is very simple, it is to give the caller the responsibility of advancing the rng state. So functions do not need to return RNG state.
</p>

<p>
<i>Note:</i> Well, some function have to return the RNG state in JAX and it's the body function of while loops. Still goes to show how broken of an abstraction it is. There needs to pass RNG state because there <i>is</i> a data dependence between the two.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">sequential</span>(rng):
    <span style="font-weight: bold; font-style: italic;">rng_y</span>, <span style="font-weight: bold; font-style: italic;">rng_z</span> = at.random.split(rng, 2)
    <span style="font-weight: bold;">return</span> call(rng_y) + call(rng_z)

<span style="font-weight: bold; font-style: italic;">sequential_et</span> = etuple(
    etuplize(at.add),
    etuple(
        call,
        etuple(
            nth,
            0,
            etuple(
                etuplize(at.random.split),
                rng,
                2
            )
        )
    ),
    etuple(
        call,
        etuple(
            nth,
            1,
            etuple(
                etuplize(at.random.split),
                rng,
                2
            )
        )
    )
)
</pre>
</div>

<p>
<b>First</b> justify the <code>split</code>, <code>rand</code> symbolic interface (reference Haskell)
</p>


<p>
Counter based approach: <a target='_blank' rel='noopener noreferrer' class='external' href="http://www.thesalmons.org/john/random123/papers/random123sc11.pdf">Parallel Random Numbers: As easy as 1, 2, 3</a>
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org39badca" class="outline-3">
<h3 id="org39badca">Why this proposal</h3>
<div class="outline-text-3" id="text-org39badca">
<p>
This proposal is motivated by two issues that illustrate the shortcomings of the current representation of <code>RandomVariable</code>\s and PRNG states in Aesara:
</p>

<ul class="org-ul">
<li>In <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aesara/pull/1036">#1036</a> the use of <code>default_output</code> to hide the PRNG state from the user is causing multiple headaches in the etuplization of <code>RandomVariable</code>\s and unification/reification of expressions with <code>RandomVariable</code>\s. This is the only <code>Op</code> in Aesara that makes use of this property, and to "special-casing" the etuplization logic for <code>RandomVariable</code>\s often appeared as the easiest solution.</li>
<li><p>
In <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aemcmc/pull/66#issuecomment-1258471312">#66</a> in AeMCMC, expressing expansions like the following convolution of two normal variables is overly complex:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> etuples <span style="font-weight: bold;">import</span> etuple
<span style="font-weight: bold;">from</span> kanren <span style="font-weight: bold;">import</span> var

<span style="font-weight: bold; font-style: italic;">mu_x</span>, <span style="font-weight: bold; font-style: italic;">mu_y</span>, <span style="font-weight: bold; font-style: italic;">sigma2_x</span>, <span style="font-weight: bold; font-style: italic;">sigma2_y</span> = var(), var(), var(), var()

<span style="font-weight: bold; font-style: italic;">rng</span>, <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; font-style: italic;">dtype</span> = var(), var(), var()
<span style="font-weight: bold; font-style: italic;">X_et</span> = etuple(
    etuplize(at.random.normal),
    rng,
    size,
    dtype,
    etuple(
        etuplize(at.add),
        mu_x,
        mu_y
    ),
    etuple(
        etuplize(at.add),
        sigma2_x,
        sigma2_y,
    )
)

<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">size_x</span>, <span style="font-weight: bold; font-style: italic;">dtype_x</span> = var(), var(), var()
<span style="font-weight: bold; font-style: italic;">rng_y</span>, <span style="font-weight: bold; font-style: italic;">size_y</span>, <span style="font-weight: bold; font-style: italic;">dtype_y</span> = var(), var(), var()
<span style="font-weight: bold; font-style: italic;">Y_et</span> = etuple(
    etuplize(at.add),
    etuple(
        etuplize(at.random.normal),
        rng_x,
        size_x,
        dtype_x,
        mu_x,
        sigma2_x
    ),
    etuple(
        etuplize(at.random.normal),
        rng_y,
        size_y,
        dtype_y,
        mu_y,
        sigma2_y
    )
)
</pre>
</div>

<p>
It is indeed not clear what the values of <code>rng_x</code> and <code>rng_y</code> should be given the value of <code>rng</code>. We should have a way to be able to create two independant RNG states from a single one.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org5b3667d" class="outline-3">
<h3 id="org5b3667d">Proposal: A Haskell-like design</h3>
<div class="outline-text-3" id="text-org5b3667d">
<p>
In the following we focus on <i>the symbolic representation of random variables and PRNG states in Aesara's IR</i>. We leave discussions about compilation of this representation, and solution to the aforementionned issues for the end.
</p>

<p>
If we represent the internal state of the PRNG by the type <code>RandState</code>, the current design of <code>RandomVariable</code>\s can be summarized by the following simplified signature:
</p>

<div class="org-src-container">
<pre class="src src-haskell">RandomVariable :: RandState -&gt; (RandState, TensorVariable)
</pre>
</div>

<p>
In other words, <code>RandomVariable</code>\s are responsible for <b>both</b> advancing the state of the PRNG, and producing a random value. This double responsibility is what creates graph dependencies between nodes that have otherwise no data dependency. The following snippet illustrates this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara
<span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.<span style="font-weight: bold;">type</span>.RandomStateType()(<span style="font-style: italic;">'rng'</span>)

<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(0, 1, rng=rng, name=<span style="font-style: italic;">'x'</span>).owner.outputs
<span style="font-weight: bold; font-style: italic;">rng_y</span>, <span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(0, 1, rng=rng_x, name=<span style="font-style: italic;">'y'</span>).owner.outputs
<span style="font-weight: bold; font-style: italic;">z_rv</span> = at.random.normal(0, 1, rng=rng_y, name=<span style="font-style: italic;">'z'</span>)
<span style="font-weight: bold; font-style: italic;">w_at</span> = x_rv + y_rv + z_rv

aesara.dprint(w_at)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Elemwise{add,no_inplace} [id A]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|Elemwise{add,no_inplace} [id B]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| |normal_rv{0, (0, 0), floatX, False}.1 [id C] 'x'</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| | |rng [id D]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| | |TensorConstant{[]} [id E]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| | |TensorConstant{11} [id F]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| | |TensorConstant{0} [id G]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| | |TensorConstant{1} [id H]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">| |normal_rv{0, (0, 0), floatX, False}.1 [id I] 'y'</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|   |normal_rv{0, (0, 0), floatX, False}.0 [id C]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|   |TensorConstant{[]} [id J]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|   |TensorConstant{11} [id K]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|   |TensorConstant{0} [id L]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|   |TensorConstant{1} [id M]</span>
<span style="font-weight: bold; font-style: italic;">#  </span><span style="font-weight: bold; font-style: italic;">|normal_rv{0, (0, 0), floatX, False}.1 [id N] 'z'</span>
<span style="font-weight: bold; font-style: italic;">#    </span><span style="font-weight: bold; font-style: italic;">|normal_rv{0, (0, 0), floatX, False}.0 [id I]</span>
<span style="font-weight: bold; font-style: italic;">#    </span><span style="font-weight: bold; font-style: italic;">|TensorConstant{[]} [id O]</span>
<span style="font-weight: bold; font-style: italic;">#    </span><span style="font-weight: bold; font-style: italic;">|TensorConstant{11} [id P]</span>
<span style="font-weight: bold; font-style: italic;">#    </span><span style="font-weight: bold; font-style: italic;">|TensorConstant{0} [id Q]</span>
<span style="font-weight: bold; font-style: italic;">#    </span><span style="font-weight: bold; font-style: italic;">|TensorConstant{1} [id R]</span>
</pre>
</div>

<p>
As we can see in the graph representation, <code>rng_x</code> (id C) is being used as an input to <code>y</code> and <code>rng_y</code> (id I) is being used as an input to <code>z</code>. There is however no data dependency between <code>x</code>, <code>y</code> or <code>z</code>. The intuition that they should not be linked is probably what led to "hiding" these PRNG state outputs so they are not re-used, and the <code>RandomStream</code> interface.
</p>

<p>
Creating spurious sequential dependencies by threading PRNG states is indeed unsatisfactory from a representation perspective, and unnecessarily complicates the rewrites. It is also problematic for two other reasons:
</p>

<ul class="org-ul">
<li><i>Parallelization and Vectorization:</i> Using random variables in user-defined generalized universal functions is going to require a lot of compiler magic to make sure that the random state is updated properly, and the behavior will be completely opaque to the user;</li>
<li>The fact that callers cannot be intentional about what they do with the random state is limiting. This can be necessary in pratical applications, for instance to implement <a target='_blank' rel='noopener noreferrer' class='external' href="https://statisfaction.wordpress.com/2017/09/17/unbiased-hamiltonian-monte-carlo-with-couplings/">coupled sampling algorithms</a> in which two algorithms share the same random state.</li>
</ul>

<p>
A first idea is to simplify the design of <code>RandomVariable</code>\s so that it is only responsible for one thing: generate a random value from a PRNG state. The <code>Op</code> thus creates an <code>Apply</code> node that takes a <code>RandState</code> (using the above notation) as input and outputs a (random) <code>Variable</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">RandomVariable :: RandState -&gt; Variable
</pre>
</div>

<p>
Providing a <code>RandState</code> to a <code>RandomVariable</code> needs to intentional, and this must be reflected in the user interface. We thus make <code>rng</code> an explicit input of the <code>RandomVariable</code>'s <code>__call__</code> method. This way a user can write:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">rng_x, rng_y and rng_z are created before that.</span>
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_rv</span> = at.random.normal(rng_z, 0, 1)
</pre>
</div>

<p>
Or, if they want the PRNG state to be shared (silly example, but a legitimate need):
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">rng_x, rng_y and rng_z are created before that.</span>
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_rv</span> = at.random.normal(rng_x, 0, 1)
</pre>
</div>

<p>
This interface presupposes the existence of two operators. First, to build reproducible programs, we need an operator that creates a <code>RandState</code> from a seed, which can be the constructor of <code>RandState</code> itself:
</p>

<div class="org-src-container">
<pre class="src src-haskell">RandState.__init__ :: Seed -&gt; RandState
</pre>
</div>

<p>
And then, we need another operator that creates an updated <code>RandomState</code> from a <code>RandomState</code>, so that <code>RandomVariable</code>\s created with these two different states would output different numbers. Let's call it <code>next</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">next :: RandomState -&gt; RandomState
</pre>
</div>

<p>
We can thus fill in the blanks in the previous code examples:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.RandState(0)
<span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.<span style="font-weight: bold;">next</span>(rng_x)
<span style="font-weight: bold; font-style: italic;">rng_z</span> = at.random.<span style="font-weight: bold;">next</span>(rng_y)

<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_rv</span> = at.random.normal(rng_z, 0, 1)

<span style="font-weight: bold; font-style: italic;">w_at</span> = x_rv + y_rv + z_rv
</pre>
</div>

<p>
The code has been specifically formatted to illustrate what we gain from this approach. <code>x_rv</code>, <code>y_rv</code> and <code>z_rv</code> have lost their direct dependency; we could easily execute these three statements in parallel. What we have done implicitly is to create two graphs: the graph between random variables which reflects the dependencies (or lack thereof) on each other's values, and the graph of the updates of the PRNG states. These graphs almost evolve in parallel.
</p>

<p>
This is similat to what I understand the <code>RandomStream</code> interface does: moving the updates of the PRNG states to the <code>update</code> graphs generated by Aesara's shared variables.
</p>

<p>
The <code>next</code> operator is however not completely satisfactory. Let us consider a more complex situation, where <code>call</code> is a function that requires a <code>RandomState</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.RandState(0)
<span style="font-weight: bold; font-style: italic;">rng_x</span> = at.random.<span style="font-weight: bold;">next</span>(rng)
<span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.<span style="font-weight: bold;">next</span>(rng_x)

<span style="font-weight: bold; font-style: italic;">x_rv</span> = call_x(rng_x)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = call_y(rng_y)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
We can easily find an implementation of <code>call</code> that makes the previous code generate a random state collision:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">call_x</span>(rng_a):
    <span style="font-weight: bold; font-style: italic;">a_rv</span> = at.random.normal(rng_a, 0, 1)
    <span style="font-weight: bold; font-style: italic;">rng_b</span> = at.random.<span style="font-weight: bold;">next</span>(rng_a)
    <span style="font-weight: bold; font-style: italic;">b_rv</span> = at.random.normal(rng_b, 0, 1)
    <span style="font-weight: bold;">return</span> a_rv * b_rv
</pre>
</div>

<p>
The issue arises because although we've separated PRNG state update and random value generation, our symbolic structure is still <i>sequential</i>: each <code>RandState</code> has one and only one ancestor. We can of course circumvent this issue knowing how many times <code>next</code> is called within the function, by "jumping" the same number of times to obtain <code>rng_y</code>, but this can quickly become complex (what if <code>call</code> is imported from somewhere else?).
</p>

<p>
It would make things easier if <code>RandState</code>\s could have several children, and if each of these child led to separate streams of random number. Let us define the following <code>split</code> operator:
</p>

<div class="org-src-container">
<pre class="src src-haskell">split :: RandState -&gt; (RandState, RandState)
</pre>
</div>

<p>
So I can never get the same <code>RandState</code> by calling split any number of times on either the left or right returned state. In other words, if <code>split</code> implicitly defines a binary tree in which all the nodes are unique. This can be easily represented by letting <code>RandState</code> be a number in binary format. The leftmost child state is obtained by appending <code>0</code> to the parent's state and the rightmost child state by appending <code>1</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> NamedTuple


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">RandState</span>(NamedTuple):
    key: <span style="font-weight: bold;">int</span>
    node_id: <span style="font-weight: bold;">int</span> = 0b1


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">split</span>(rng):
    <span style="font-weight: bold; font-style: italic;">left</span> = RandState(rng.key, rng.node_id &lt;&lt; 2)
    <span style="font-weight: bold; font-style: italic;">right</span> = RandState(rng.key, (rng.node_id &lt;&lt; 2) + 1)
    <span style="font-weight: bold;">return</span> left, right


<span style="font-weight: bold; font-style: italic;">rng</span> = RandState(0)
<span style="font-weight: bold; font-style: italic;">l</span>, <span style="font-weight: bold; font-style: italic;">r</span> = split(rng)
<span style="font-weight: bold; font-style: italic;">ll</span>, <span style="font-weight: bold; font-style: italic;">lr</span> = split(l)

<span style="font-weight: bold;">print</span>(rng, l, lr)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">RandState(key=0, node_id=1) RandState(key=0, node_id=4) RandState(key=0, node_id=17)</span>
</pre>
</div>

<p>
If the generator called by <code>RandomVariable</code> can be made a deterministic function of this binary value, the computations are fully reproducible. We added a <code>key</code> attribute that can be specified by the user at initialization to seed the PRNG state. Note that the tree structure is explicit in our graph representation, since <code>l</code> and <code>r</code> would depend on <code>rng</code> via the split operator, but this internal state can nevertheless be incremented at runtime to be used at compilation time.
</p>

<p>
The previous <code>next</code> operator becomes redundant within this representation, and its interaction with the <code>split</code> operator requires careful thought anyway. We forget it for now and our toy example becomes:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.RandState(0)
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.split(rng)

<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
It is also natural to implement the <code>splitn</code> operator represented by:
</p>

<div class="org-src-container">
<pre class="src src-haskell">splitn :: RandState -&gt; Int -&gt; (RandState, ..., RandState)
</pre>
</div>

<p>
So we can write the following code:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">at.random.split</span> = at.random.Split()

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng()
<span style="font-weight: bold; font-style: italic;">rng_v</span>, <span style="font-weight: bold; font-style: italic;">rng_w</span>, <span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.splitn(rng, 4)

<span style="font-weight: bold; font-style: italic;">v_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">w_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = v_rv + w_rv + x_rv + z_rv
</pre>
</div>

<p>
The "main" sub-graph and the PRNG sub-graph are still minimally connected. It also seems like it would be easy to re-construct the latter after performing rewrites on the former.
</p>
</div>

<div id="outline-container-org6ffd5f7" class="outline-4">
<h4 id="org6ffd5f7">Implementation</h4>
<div class="outline-text-4" id="text-org6ffd5f7">
<p>
When it comes to practical implementations, this representation is only convenient for counter-based PRNGs like <code>Philox</code> implemented in NumPy: we generate a pair of <code>(key, counter)</code> from our <code>RandState</code>\s and pass these as an input to the generator.
</p>
</div>


<ul class="org-ul">
<li><a id="orgaca71d9"></a><code>RandState</code> and <code>split</code> implementation<br />
<div class="outline-text-5" id="text-orgaca71d9">
<p>
The mock implementation of <code>RandState</code> and <code>split</code> above is naive in the sense that the counter space \(\mathcal{S}\) of real PRNGs does not usually extend indefinitely. In practice we will need to compress the state using a hashing function that also increments the <code>key</code>.
</p>

<p>
To be immediately compatible with NumPy in the <code>perform</code> function we can use Philox's hash function to update the state as we build the graph. Since the hash is deterministic we can still walk the <code>RandState</code> tree in our representation and cheaply recompute the states should we need to.
</p>

<p>
<i>Op and Variable implementations to come</i>
</p>
</div>
</li>

<li><a id="org486e1e6"></a><code>=RandomVariable</code><br />
<div class="outline-text-5" id="text-org486e1e6">
<p>
The modifications to <code>RandomVariable</code> Ops is minimal: we need to modify their <code>__call__</code>, <code>make_node</code> and <code>perform</code> methods. <code>default_output</code> is not needed as we do not return a <code>RandomState</code> anymore.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.graph.op <span style="font-weight: bold;">import</span> Op


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">RandomVariable</span>(Op)
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__call__</span>(<span style="font-weight: bold;">self</span>, rng, *args, size=<span style="font-weight: bold; text-decoration: underline;">None</span>, name=<span style="font-weight: bold; text-decoration: underline;">None</span>, dtype=<span style="font-weight: bold; text-decoration: underline;">None</span>, **kwargs):
        <span style="font-weight: bold; font-style: italic;">res</span> = <span style="font-weight: bold;">super</span>().__call__(rng, size, dtype, *args, **kwargs)

        <span style="font-weight: bold;">if</span> name <span style="font-weight: bold;">is</span> <span style="font-weight: bold;">not</span> <span style="font-weight: bold; text-decoration: underline;">None</span>:
            <span style="font-weight: bold; font-style: italic;">res.name</span> = name

        <span style="font-weight: bold;">return</span> res

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">make_node</span>(<span style="font-weight: bold;">self</span>, rng, size, dtype, *dist_params):
        <span style="font-style: italic;">"""Create a random variable node.</span>

<span style="font-style: italic;">        Parameters</span>
<span style="font-style: italic;">        ----------</span>
<span style="font-style: italic;">        rng: RandState</span>
<span style="font-style: italic;">        size: int or Sequence</span>
<span style="font-style: italic;">            NumPy-like size parameter.</span>
<span style="font-style: italic;">        dtype: str</span>
<span style="font-style: italic;">            The dtype of the sampled output.  If the value ``"floatX"`` is</span>
<span style="font-style: italic;">            given, then `dtype` is set to ``aesara.config.floatX``.  This value is</span>
<span style="font-style: italic;">            only used when ``self.dtype`` isn't set.</span>
<span style="font-style: italic;">        dist_params: list</span>
<span style="font-style: italic;">            Distribution parameters.</span>

<span style="font-style: italic;">        Results</span>
<span style="font-style: italic;">        -------</span>
<span style="font-style: italic;">        out: Apply</span>
<span style="font-style: italic;">            A node with inputs ``(rng, size, dtype) + dist_args`` and outputs</span>
<span style="font-style: italic;">            ``(out_var)``.</span>

<span style="font-style: italic;">        """</span>
        <span style="font-weight: bold; font-style: italic;">size</span> = normalize_size_param(size)

        <span style="font-weight: bold; font-style: italic;">dist_params</span> = <span style="font-weight: bold;">tuple</span>(
            as_tensor_variable(p) <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">not</span> <span style="font-weight: bold;">isinstance</span>(p, Variable) <span style="font-weight: bold;">else</span> p
            <span style="font-weight: bold;">for</span> p <span style="font-weight: bold;">in</span> dist_params
        )

        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">`rng` needs to be explicitly provided.</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">if rng is None:</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">rng = aesara.shared(np.random.default_rng())</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">elif not isinstance(rng.type, RandomType):</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">raise TypeError(</span>
        <span style="font-weight: bold; font-style: italic;">#         </span><span style="font-weight: bold; font-style: italic;">"The type of rng should be an instance of either RandomGeneratorType or RandomStateType"</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">)</span>

        <span style="font-weight: bold; font-style: italic;">shape</span> = <span style="font-weight: bold;">self</span>._infer_shape(size, dist_params)
        <span style="font-weight: bold; font-style: italic;">_</span>, <span style="font-weight: bold; font-style: italic;">bcast</span> = infer_broadcastable(shape)
        <span style="font-weight: bold; font-style: italic;">dtype</span> = <span style="font-weight: bold;">self</span>.dtype <span style="font-weight: bold;">or</span> dtype

        <span style="font-weight: bold;">if</span> dtype == <span style="font-style: italic;">"floatX"</span>:
            <span style="font-weight: bold; font-style: italic;">dtype</span> = config.floatX
        <span style="font-weight: bold;">elif</span> dtype <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span> <span style="font-weight: bold;">or</span> (<span style="font-weight: bold;">isinstance</span>(dtype, <span style="font-weight: bold;">str</span>) <span style="font-weight: bold;">and</span> dtype <span style="font-weight: bold;">not</span> <span style="font-weight: bold;">in</span> all_dtypes):
            <span style="font-weight: bold;">raise</span> <span style="font-weight: bold; text-decoration: underline;">TypeError</span>(<span style="font-style: italic;">"dtype is unspecified"</span>)

        <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">isinstance</span>(dtype, <span style="font-weight: bold;">str</span>):
            <span style="font-weight: bold; font-style: italic;">dtype_idx</span> = constant(all_dtypes.index(dtype), dtype=<span style="font-style: italic;">"int64"</span>)
        <span style="font-weight: bold;">else</span>:
            <span style="font-weight: bold; font-style: italic;">dtype_idx</span> = constant(dtype, dtype=<span style="font-style: italic;">"int64"</span>)
            <span style="font-weight: bold; font-style: italic;">dtype</span> = all_dtypes[dtype_idx.data]

        <span style="font-weight: bold; font-style: italic;">outtype</span> = TensorType(dtype=dtype, shape=bcast)
        <span style="font-weight: bold; font-style: italic;">out_var</span> = outtype()
        <span style="font-weight: bold; font-style: italic;">inputs</span> = (rng, size, dtype_idx) + dist_params
        <span style="font-weight: bold; font-style: italic;">output</span> = (out_var,)

        <span style="font-weight: bold;">return</span> Apply(<span style="font-weight: bold;">self</span>, inputs, outputs)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">perform</span>(<span style="font-weight: bold;">self</span>, node, inputs, outputs):
        <span style="font-weight: bold; font-style: italic;">smpl_out</span> = outputs
        rng, size, dtype, *<span style="font-weight: bold; font-style: italic;">args</span> = inputs

        <span style="font-weight: bold; font-style: italic;">out_var</span> = node.outputs[1]

        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">If `size == []`, that means no size is enforced, and NumPy is trusted</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">to draw the appropriate number of samples, NumPy uses `size=None` to</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">represent that.  Otherwise, NumPy expects a tuple.</span>
        <span style="font-weight: bold;">if</span> np.size(size) == 0:
            <span style="font-weight: bold; font-style: italic;">size</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>
        <span style="font-weight: bold;">else</span>:
            <span style="font-weight: bold; font-style: italic;">size</span> = <span style="font-weight: bold;">tuple</span>(size)

        <span style="font-weight: bold; font-style: italic;">##</span><span style="font-weight: bold; font-style: italic;">----------------------##</span>
        <span style="font-weight: bold; font-style: italic;">##  </span><span style="font-weight: bold; font-style: italic;">THE IMPORTANT STUFF ##</span>
        <span style="font-weight: bold; font-style: italic;">##</span><span style="font-weight: bold; font-style: italic;">----------------------##</span>
        <span style="font-weight: bold; font-style: italic;">rng</span> = np.random.Generator(np.random.Philox(key=rng.key, counter=rng.counter))
        <span style="font-weight: bold; font-style: italic;">smpl_val</span> = <span style="font-weight: bold;">self</span>.rng_fn(rng, *(args + [size]))
        <span style="font-weight: bold; font-style: italic;">##</span><span style="font-weight: bold; font-style: italic;">----------------------##</span>
        <span style="font-weight: bold; font-style: italic;">##  </span><span style="font-weight: bold; font-style: italic;">THE IMPORTANT STUFF ##</span>
        <span style="font-weight: bold; font-style: italic;">##</span><span style="font-weight: bold; font-style: italic;">----------------------##</span>

        <span style="font-weight: bold;">if</span> (
            <span style="font-weight: bold;">not</span> <span style="font-weight: bold;">isinstance</span>(smpl_val, np.ndarray)
            <span style="font-weight: bold;">or</span> <span style="font-weight: bold;">str</span>(smpl_val.dtype) != out_var.<span style="font-weight: bold;">type</span>.dtype
        ):
            <span style="font-weight: bold; font-style: italic;">smpl_val</span> = _asarray(smpl_val, dtype=out_var.<span style="font-weight: bold;">type</span>.dtype)

        <span style="font-weight: bold; font-style: italic;">smpl_out</span>[0] = smpl_val

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">rng_fn</span>(<span style="font-weight: bold;">self</span>, rng, *args, **kwargs):
        <span style="font-style: italic;">"""Sample a numeric random variate."""</span>
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">getattr</span>(rng, <span style="font-weight: bold;">self</span>.name)(*args, **kwargs)
</pre>
</div>
</div>
</li>

<li><a id="org96ac701"></a><code>RandomStream</code><br />
<div class="outline-text-5" id="text-org96ac701">
<p>
We can keep the <code>RandomStream</code> API, use a shared variable to hold the <code>RandState</code> and handle the splitting internally. Note that this interface would not be as flexible as the explicit interface:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">gen</span>(<span style="font-weight: bold;">self</span>, op: <span style="font-style: italic;">"RandomVariable"</span>, *args, **kwargs) -&gt; TensorVariable:
    r<span style="font-style: italic;">"""Generate a draw from `op` seeded from this `RandomStream`.</span>

<span style="font-style: italic;">    Parameters</span>
<span style="font-style: italic;">    ----------</span>
<span style="font-style: italic;">    op</span>
<span style="font-style: italic;">        A `RandomVariable` instance</span>
<span style="font-style: italic;">    args</span>
<span style="font-style: italic;">        Positional arguments passed to `op`.</span>
<span style="font-style: italic;">    kwargs</span>
<span style="font-style: italic;">        Keyword arguments passed to `op`.</span>

<span style="font-style: italic;">    Returns</span>
<span style="font-style: italic;">    -------</span>
<span style="font-style: italic;">    The symbolic random draw performed by `op`.  This function stores</span>
<span style="font-style: italic;">    the updated `RandomType`\s for use at compile time.</span>

<span style="font-style: italic;">    """</span>
    <span style="font-weight: bold;">if</span> <span style="font-style: italic;">"rng"</span> <span style="font-weight: bold;">in</span> kwargs:
        <span style="font-weight: bold;">raise</span> <span style="font-weight: bold; text-decoration: underline;">ValueError</span>(
            <span style="font-style: italic;">"The `rng` option cannot be used with a variate in a `RandomStream`"</span>
        )

    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Update the random state and take a sample</span>
    <span style="font-weight: bold; font-style: italic;">_</span>, <span style="font-weight: bold;">self</span>.rng = at.random.split(<span style="font-weight: bold;">self</span>.rng)
    <span style="font-weight: bold; font-style: italic;">out</span> = op(<span style="font-weight: bold;">self</span>.rng, *args, **kwargs)

    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">This is the value that should be used to replace the old state</span>
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">(i.e. `rng`) after `out` is sampled/evaluated.</span>
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">The updates mechanism in `aesara.function` is supposed to perform</span>
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">this replace action.</span>
    <span style="font-weight: bold; font-style: italic;">new_rng</span> = out.owner.outputs[0]

    <span style="font-weight: bold;">self</span>.state_updates.append((rng, new_rng))  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">happens here</span>

    <span style="font-weight: bold; font-style: italic;">rng.default_update</span> = new_rng

    <span style="font-weight: bold;">return</span> out
</pre>
</div>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgdc7413d" class="outline-4">
<h4 id="orgdc7413d">Transpilation</h4>
<div class="outline-text-4" id="text-orgdc7413d">
</div>
<ul class="org-ul">
<li><a id="org5f0484e"></a>Numba<br />
<div class="outline-text-5" id="text-org5f0484e">
<p>
After <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aesara/pull/1245">#1245</a> Aesara will support NumPy's Generator API. NumPy has support for <a target='_blank' rel='noopener noreferrer' class='external' href="https://numpy.org/doc/stable/reference/random/bit_generators/philox.html">Philox as a BitGenerator</a>. Philox is a <a target='_blank' rel='noopener noreferrer' class='external' href="http://www.thesalmons.org/john/random123/papers/random123sc11.pdf">counter-based PRNG</a> which can easily accomodate <a target='_blank' rel='noopener noreferrer' class='external' href="https://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf">splittable PRNG representations</a>. Assuming we use Philox's hash function directly in the Aesara graph, the transpilation of <code>RandomStream</code>\s should be straighforward. For the explicit interface, we can directly translate the <code>RandomVariable</code>\s to NumPy <code>Generator</code>\s and seed these generators at compile time. So that:
</p>

<div class="org-src-container">
<pre class="src src-python">at.random.normal(rng, 0, 1)
</pre>
</div>

<p>
Becomes:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">rng</span> = np.random.Generator(np.random.Philox(counter=rng.counter, key=rng.key))
rng.normal(0, 1)
</pre>
</div>

<p>
Alternatively, we could interpret the structure of the RNG-Variables graph, initialize one <code>np.random.Generator</code> and use the <code>jumped</code> and <code>advance</code> methods of the Philox <code>BitGenerator</code>.
</p>
</div>
</li>

<li><a id="org5919b04"></a>JAX<br />
<div class="outline-text-5" id="text-org5919b04">
<p>
Transpilation to JAX would be straightforward, as JAX <a target='_blank' rel='noopener noreferrer' class='external' href="https://jax.readthedocs.io/en/latest/jep/263-prng.html">uses a splittable PRNG representation</a>. We will simply need to perform the following substitutions:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">rng</span> = at.random.RandomState()
<span style="font-weight: bold; font-style: italic;">rng_key</span> = jax.random.PRNGKey()

at.random.split(rng)
jax.random.split(rng_key)

at.random.splitn(rng, 10)
jax.random.split(rng_key, 10)
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org8610bd0" class="outline-4">
<h4 id="org8610bd0">Etuplization</h4>
<div class="outline-text-4" id="text-org8610bd0">
<p>
These new operators simplify greatly the work with etuplized versions of graphs with random variables. Assuming we have a <code>Nth</code> operator in Aesara as well:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> etuples <span style="font-weight: bold;">import</span> ExpressionTuple, etuplize
<span style="font-weight: bold;">from</span> aesara.graph.rewriting.unify <span style="font-weight: bold;">import</span> OpExpressionTuple

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng()
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.split(rng)
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv

<span style="font-weight: bold; font-style: italic;">z_et</span> = OpExpressionTuple(
    etuplize(at.add),
    OpExpressionTuple(
        etuplize(at.random.normal),
        ExpressionTuple(
           etuplize(aesara.graph.nth),
           1,
           OpExpressionTuple(
               etuplize(at.random.split)
               rng
           )
        ),
        0,
        1,
        size,
        dtype,
    ),
    OpExpressionTuple(
        etuplize(at.random.normal),
        ExpressionTuple(
           etuplize(aesara.graph.nth),
           0,
           OpExpressionTuple(
               etuplize(at.random.split)
               rng
           )
        ),
        0,
        1,
        size,
        dtype,
    ),
)
</pre>
</div>

<p>
This solves the one-to-many problem we had for mixtures. If we have a relation between a single random variable and two we can now write:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">z_et</span> = etuple(etuplize(at.random.normal), rng_lv, size_lv, dtype_lv, at.as_tensor(1.), at.as_tensor(2.))

<span style="font-weight: bold; font-style: italic;">sum_et</span> = etuple(
    etuplize(at.add),
    etuple(
        etuplize(at.random.normal),
        etuple(
            etuplize(at.graph.nth),
            0,
            etuple(
                etuplize(at.random.split),
                rng_lv,
            )
        )
        size_lv,
        dtype_lv,
        at.as_tensor(0.),
        at.as_tensor(1.),
    ),
    etuple(
        etuplize(at.random.normal),
        etuple(
            etuplize(at.graph.nth),
            1,
            etuple(
                etuplize(at.random.split),
                rng_lv,
            )
        )
        size_lv,
        dtype_lv,
        at.as_tensor(0.),
        at.as_tensor(1.),
    )
)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6711c9f" class="outline-2">
<h2 id="org6711c9f">RandomVariable Ops</h2>
<div class="outline-text-2" id="text-org6711c9f">
<p>
We have a <code>default_rng</code> function, but the result does not behave as a generator in <code>numpy</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> default_rng
<span style="font-weight: bold; font-style: italic;">rng</span> = default_rng(32)
rng.<span style="font-weight: bold;">type</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.tensor.random.basic <span style="font-weight: bold;">import</span> NormalRV

<span style="font-weight: bold; font-style: italic;">norm</span> = NormalRV()
<span style="font-weight: bold; font-style: italic;">norm_rv</span> = norm(0, 1, size=(2,), rng=rng)

norm_rv.<span style="font-weight: bold;">eval</span>()
</pre>
</div>


<p>
<code>Aesara</code> also defines aliases for the <code>RandomVariable</code> Ops:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> normal

<span style="font-weight: bold; font-style: italic;">normal_rv</span> = normal(0, 1, size=(2,), rng=rng)
normal_rv.<span style="font-weight: bold;">eval</span>()
</pre>
</div>

<p>
Let's look at the graphs that are produced:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara
<span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> default_rng, normal

<span style="font-weight: bold; font-style: italic;">rng</span> = default_rng(0)
<span style="font-weight: bold; font-style: italic;">a_rv</span> = normal(0, 1, rng=rng)
<span style="font-weight: bold; font-style: italic;">b_rv</span> = normal(0, 1, rng=rng)
<span style="font-weight: bold; font-style: italic;">c_tt</span> = a_rv + b_rv

<span style="font-weight: bold; font-style: italic;">d_rv</span> = normal(0, 1, rng=rng)

aesara.dprint(c_tt * d_rv)
</pre>
</div>


<p>
How does <code>RandomGeneratorType</code> work? It looks like it has internal state.
</p>
</div>
</div>

<div id="outline-container-org36e5ded" class="outline-2">
<h2 id="org36e5ded">Define custom random variables</h2>
<div class="outline-text-2" id="text-org36e5ded">
<p>
It is fairly simple as <code>srng.gen(RV, *args)</code> will call <code>RV()(random_state, *args)</code>.
</p>

<div class="org-src-container">
<pre class="src src-python">srng.gen(zero_truncated_betabinom, eta_at, kappa_rv, n_at),
</pre>
</div>

<p>
where the <code>RandomVariable</code> is implemented as:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">ZeroTruncatedBetaBinomial</span>(RandomVariable):
    r<span style="font-style: italic;">"""A zero-truncated beta-binomial distribution.</span>

<span style="font-style: italic;">    This distribution is implemented in the :math:`\kappa`</span>
<span style="font-style: italic;">    and :math:`\eta` parameterization, which is related to</span>
<span style="font-style: italic;">    the standard :math:`\alpha` and :math:`\beta` parameterization</span>
<span style="font-style: italic;">    of the beta-binomial through the following:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \alpha = \eta / \kappa \\</span>
<span style="font-style: italic;">        \beta = (1 - \eta) / \kappa</span>

<span style="font-style: italic;">    Truncation aside, for a :math:`Y \sim \operatorname{BetaBinom}\left(N, \eta, \kappa\right)`,  # noqa: E501</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \operatorname{E}\left[ Y \right] = N \eta \\</span>
<span style="font-style: italic;">        \operatorname{Var}\left[ Y \right] = N \eta (1 - \eta) (N \kappa + 1) / (\kappa + 1)</span>


<span style="font-style: italic;">    Under this parameterization, :math:`\kappa` in the standard beta-binomial</span>
<span style="font-style: italic;">    serves as an over-dispersion term with the following properties:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \lim_{\kappa \to 0} \operatorname{Var}\left[ Y \right] = N \eta (1 - \eta) \\</span>
<span style="font-style: italic;">        \lim_{\kappa \to \infty} \operatorname{Var}\left[ Y \right] = N^2 \eta (1 - \eta)</span>

<span style="font-style: italic;">    In other words, :math:`\kappa` modulates between the standard binomial</span>
<span style="font-style: italic;">    variance and :math:`N`-times that variance.</span>

<span style="font-style: italic;">    The un-truncated probability mass function (PMF) is as follows:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \frac{\operatorname{B}\left(\frac{\eta}{\kappa} + y, n - y + \frac{1 - \eta}{\kappa}\right) {\binom{n}{y}}}{\operatorname{B}\left(\frac{\eta}{\kappa}, \frac{1 - \eta}{\kappa}\right)}  # noqa: E501</span>

<span style="font-style: italic;">    and the zero-truncated PMF is as follows:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \frac{\operatorname{B}\left(\frac{\eta}{\kappa} + y, - \frac{\eta}{\kappa} + n - y + \frac{1}{\kappa}\right) {\binom{n}{y}}}{\operatorname{B}\left(\frac{\eta}{\kappa}, - \frac{\eta}{\kappa} + \frac{1}{\kappa}\right) - \operatorname{B}\left(\frac{\eta}{\kappa}, - \frac{\eta}{\kappa} + n + \frac{1}{\kappa}\right)}  # noqa: E501</span>

<span style="font-style: italic;">    """</span>
    <span style="font-weight: bold; font-style: italic;">name</span> = <span style="font-style: italic;">"zero_truncated_betabinom"</span>
    <span style="font-weight: bold; font-style: italic;">ndim_supp</span> = 0
    <span style="font-weight: bold; font-style: italic;">ndims_params</span> = [0, 0, 0]
    <span style="font-weight: bold; font-style: italic;">dtype</span> = <span style="font-style: italic;">"int64"</span>
    <span style="font-weight: bold; font-style: italic;">_print_name</span> = (<span style="font-style: italic;">"ZeroTruncBetaBinom"</span>, <span style="font-style: italic;">"\\operatorname{BetaBinom}_{&gt;0}"</span>)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, rejection_threshold=200, **kwargs):
        <span style="font-style: italic;">"""</span>
<span style="font-style: italic;">        Parameters</span>
<span style="font-style: italic;">        ----------</span>
<span style="font-style: italic;">        rejection_threshold</span>
<span style="font-style: italic;">            The number of rejection iterations to perform before raising an</span>
<span style="font-style: italic;">            exception.</span>
<span style="font-style: italic;">        """</span>
        <span style="font-weight: bold;">self</span>.rejection_threshold = rejection_threshold
        <span style="font-weight: bold;">super</span>().__init__(**kwargs)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__call__</span>(<span style="font-weight: bold;">self</span>, eta, kappa, n, size=<span style="font-weight: bold; text-decoration: underline;">None</span>, **kwargs):
        <span style="font-style: italic;">"""</span>
<span style="font-style: italic;">        Parameters</span>
<span style="font-style: italic;">        ----------</span>
<span style="font-style: italic;">        eta</span>
<span style="font-style: italic;">        kappa</span>
<span style="font-style: italic;">        n</span>
<span style="font-style: italic;">        """</span>

        <span style="font-weight: bold;">self</span>.eta = at.as_tensor_variable(eta, dtype=aesara.config.floatX)
        <span style="font-weight: bold;">self</span>.kappa = at.as_tensor_variable(kappa, dtype=aesara.config.floatX)
        <span style="font-weight: bold;">self</span>.n = at.as_tensor_variable(n, dtype=np.int64)

        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">super</span>().__call__(eta, kappa, n, size=size, **kwargs)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">rng_fn</span>(<span style="font-weight: bold;">self</span>, rng, eta, kappa, n, size):
        <span style="font-style: italic;">"""A naive hybrid rejection + inverse sampler."""</span>

        <span style="font-weight: bold; font-style: italic;">n</span> = np.asarray(n, dtype=np.int64)
        <span style="font-weight: bold; font-style: italic;">eta</span> = np.asarray(eta, dtype=np.float64)
        <span style="font-weight: bold; font-style: italic;">kappa</span> = np.asarray(kappa, dtype=np.float64)

        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Values below this will produce errors (plus, it means this is really</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">a binomial)</span>
        <span style="font-weight: bold; font-style: italic;">alpha</span> = np.clip(eta / kappa, near_zero, 1e100)
        <span style="font-weight: bold; font-style: italic;">beta</span> = np.clip((1 - eta) / kappa, near_zero, 1e100)

        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">def zt_bb_inv(n, alpha, beta, size=None):</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">"""A zero-truncated beta-binomial inverse sampler."""</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;"># bb_dist = scipy.stats.betabinom(n, alpha, beta)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">beta_smpls = np.clip(</span>
        <span style="font-weight: bold; font-style: italic;">#         </span><span style="font-weight: bold; font-style: italic;">scipy.stats.beta(alpha, beta).rvs(size=size), 1e-10, np.inf</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">binom_dist = scipy.stats.binom(n, beta_smpls)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">u = np.random.uniform(size=size)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">F_0 = binom_dist.cdf(0)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">samples = binom_dist.ppf(F_0 + u * (1 - F_0))</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">return samples</span>

        <span style="font-weight: bold; font-style: italic;">samples</span> = scipy.stats.betabinom(n, alpha, beta).rvs(size=size, random_state=rng)
        <span style="font-weight: bold; font-style: italic;">alpha</span> = np.broadcast_to(alpha, samples.shape)
        <span style="font-weight: bold; font-style: italic;">beta</span> = np.broadcast_to(beta, samples.shape)
        <span style="font-weight: bold; font-style: italic;">n</span> = np.broadcast_to(n, samples.shape)
        <span style="font-weight: bold; font-style: italic;">rejects</span> = samples &lt;= 0

        <span style="font-weight: bold; font-style: italic;">thresh_count</span> = 0
        <span style="font-weight: bold;">while</span> rejects.<span style="font-weight: bold;">any</span>():
            <span style="font-weight: bold; font-style: italic;">_n</span> = n[rejects] <span style="font-weight: bold;">if</span> np.size(n) &gt; 1 <span style="font-weight: bold;">else</span> n
            <span style="font-weight: bold; font-style: italic;">_alpha</span> = alpha[rejects] <span style="font-weight: bold;">if</span> np.size(alpha) &gt; 1 <span style="font-weight: bold;">else</span> alpha
            <span style="font-weight: bold; font-style: italic;">_beta</span> = beta[rejects] <span style="font-weight: bold;">if</span> np.size(beta) &gt; 1 <span style="font-weight: bold;">else</span> beta
            <span style="font-weight: bold; font-style: italic;">_size</span> = rejects.<span style="font-weight: bold;">sum</span>()

            <span style="font-weight: bold; font-style: italic;">beta_smpls</span> = np.clip(
                scipy.stats.beta(_alpha, _beta).rvs(size=_size, random_state=rng),
                near_zero,
                near_one,
            )
            <span style="font-weight: bold; font-style: italic;">samples</span>[rejects] = scipy.stats.binom(_n, beta_smpls).rvs(
                size=_size, random_state=rng
            )
            <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">samples[rejects] = scipy.stats.betabinom(_n, _alpha, _beta).rvs(size=_size)  # noqa: E501</span>

            <span style="font-weight: bold; font-style: italic;">new_rejects</span> = samples &lt;= 0
            <span style="font-weight: bold;">if</span> new_rejects.<span style="font-weight: bold;">sum</span>() == rejects.<span style="font-weight: bold;">sum</span>():
                <span style="font-weight: bold;">if</span> thresh_count &gt; <span style="font-weight: bold;">self</span>.rejection_threshold:
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;"># Attempt rejection sampling until the rejection results</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;"># get stuck, then use the inverse-sampler</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">samples[rejects] = zt_bb_inv(_n, _alpha, _beta, size=_size)</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">break</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">raise ValueError("The sampling rejection threshold was met")</span>
                    warnings.warn(
                        <span style="font-style: italic;">"The sampling rejection threshold was met "</span>
                        <span style="font-style: italic;">"and mean values were used as sample values"</span>
                    )
                    <span style="font-weight: bold; font-style: italic;">sp_ref_dist</span> = scipy.stats.betabinom(_n, _alpha, _beta)
                    <span style="font-weight: bold; font-style: italic;">trunc_mean</span> = sp_ref_dist.mean() / (1 - sp_ref_dist.cdf(0))
                    <span style="font-weight: bold;">assert</span> np.<span style="font-weight: bold;">all</span>(trunc_mean &gt;= 1)
                    <span style="font-weight: bold; font-style: italic;">samples</span>[rejects] = trunc_mean
                    <span style="font-weight: bold;">break</span>
                <span style="font-weight: bold;">else</span>:
                    <span style="font-weight: bold; font-style: italic;">thresh_count</span> += 1
            <span style="font-weight: bold;">else</span>:
                <span style="font-weight: bold; font-style: italic;">thresh_count</span> = 0

            <span style="font-weight: bold; font-style: italic;">rejects</span> = new_rejects

        <span style="font-weight: bold;">return</span> samples


<span style="font-weight: bold; font-style: italic;">zero_truncated_betabinom</span> = ZeroTruncatedBetaBinomial()


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">_logp</span>(value, eta, kappa, n):
    <span style="font-weight: bold;">return</span> (
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">binomln(n, value)</span>
        -at.log(n + 1)
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- betaln(n - value + 1, value + 1)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">+ betaln(value + alpha, n - value + beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- betaln(alpha, beta)</span>
        - at.gammaln(n - value + 1)
        - at.gammaln(value + 1)
        + at.gammaln(n + 2)
        + at.gammaln(value + eta / kappa)
        + at.gammaln(n - value + (1 - eta) / kappa)
        - at.gammaln(1 / kappa + n)
        - at.gammaln(eta / kappa)
        - at.gammaln((1 - eta) / kappa)
        + at.gammaln(1 / kappa)
    )


<span style="font-weight: bold; text-decoration: underline;">@_logprob.register</span>(ZeroTruncatedBetaBinomial)
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">zero_truncated_betabinom_logprob</span>(op, values, *inputs, **kwargs):
    (values,) = values
    (eta, kappa, n) = inputs[3:]

    <span style="font-weight: bold; font-style: italic;">l0</span> = (
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">gammaln(alpha + beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">+ gammaln(n + beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- gammaln(beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- gammaln(alpha + beta + n)</span>
        at.gammaln(1 / kappa)
        + at.gammaln(n + (1 - eta) / kappa)
        - at.gammaln((1 - eta) / kappa)
        - at.gammaln(1 / kappa + n)
    )

    <span style="font-weight: bold; font-style: italic;">log1mP0</span> = at.log1mexp(l0)
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">log1mP0 = 0</span>

    <span style="font-weight: bold; font-style: italic;">res</span> = CheckParameterValue(<span style="font-style: italic;">"values &lt;= n, eta &gt; 0, kappa &gt; 0"</span>)(
        at.switch(values &gt; 0, _logp(values, eta, kappa, n) - log1mP0, -np.inf),
        at.<span style="font-weight: bold;">all</span>(values &lt;= n),
        at.<span style="font-weight: bold;">all</span>(eta &gt; 0),
        at.<span style="font-weight: bold;">all</span>(kappa &gt; 0),
    )
    <span style="font-weight: bold;">return</span> res
</pre>
</div>

<p>
Note that you can also define this random variables' logprob dispatching <code>_logprob</code> for the <code>ZeroTruncBetaBinom</code>.
</p>
</div>
</div>

<div id="outline-container-orgdc37824" class="outline-2">
<h2 id="orgdc37824">Sampling vs Logprobability <code>aeppl</code></h2>
<div class="outline-text-2" id="text-orgdc37824">
<ul class="org-ul">
<li>How define the logprob of a custom distribution?</li>
</ul>
</div>
</div>

<div id="outline-container-org7de69ab" class="outline-2">
<h2 id="org7de69ab">Shapes</h2>
<div class="outline-text-2" id="text-org7de69ab">
<p>
Shapes are always a mess when it comes to random variables. In <code>aesara</code> we note two distinct shapes:
</p>
<ul class="org-ul">
<li><code>ndim_supp</code> the number of dimensions of the RV's support.</li>
<li><code>ndim_params</code></li>
<li><code>size</code> which is the sample size</li>
</ul>

<p>
Remember that shapes in Aesara can be determined at runtime! So if we assume that:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">batch_shape</span> = size
np.ndim(sample_shape) = ndim_supp
<span style="font-weight: bold; font-style: italic;">shape</span> = sample_shape + batch_shape
</pre>
</div>

<p>
And we should have a look at broadcasting rules because they are not all very obvious.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at
<span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> RandomStream

<span style="font-weight: bold; font-style: italic;">srng</span> = RandomStream(0)
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.normal(0, 1, size=(2,3))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">mu</span> = at.as_tensor([1., 2., 3.])
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.normal(mu, 1, size=(2,3))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">mu</span> = at.as_tensor([1., 2.])
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.normal(mu, 1, size=(2,3))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>())
</pre>
</div>

<p>
More complex is the case where the random variable is non-scalar, as multivariate normal. Here you can see that the "event shape" is equal to 2. The resulting shape, if we assume <code>event_shape</code> and <code>batch_shape</code> are tuples is given by:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">shape</span> = event_shape + batch_shape
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np

<span style="font-weight: bold; font-style: italic;">mu</span> = np.r_[1, 2]
<span style="font-weight: bold; font-style: italic;">sigma</span> = np.array([[.5, .5], [.4, .6]])
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.multivariate_normal(mu, sigma, size=(2, 5))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>().shape)
</pre>
</div>

<p>
See <a target='_blank' rel='noopener noreferrer' class='external' href="https://ericmjl.github.io/blog/2019/5/29/reasoning-about-shapes-and-probability-distributions/">Eric Ma's blog post on the topic</a>.
</p>
</div>
</div>

<div id="outline-container-orgc96068e" class="outline-2">
<h2 id="orgc96068e">Problems with <code>RandomStream</code></h2>
<div class="outline-text-2" id="text-orgc96068e">
<p>
<a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aesara/pull/1211#discussion_r985057882">https://github.com/aesara-devs/aesara/pull/1211#discussion_r985057882</a>
</p>
</div>
</div>

<div id="outline-container-orgd808726" class="outline-2">
<h2 id="orgd808726">Proposal</h2>
<div class="outline-text-2" id="text-orgd808726">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.RandomState()

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">RandomVariables divide the rng</span>
<span style="font-weight: bold; font-style: italic;">a_rv</span>, <span style="font-weight: bold; font-style: italic;">rng</span> = at.random.normal(rng, 0, 1)
<span style="font-weight: bold; font-style: italic;">b_rv</span>, <span style="font-weight: bold; font-style: italic;">_</span> = at.random.normal(rng, 0, 1)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We have to update the rng manually</span>
<span style="font-weight: bold; font-style: italic;">a_rv</span> = at.random.normal(rng, 0, 1)
<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.update(rng)
<span style="font-weight: bold; font-style: italic;">b_rv</span> = at.random.normal(rng, 0, 1)

<span style="font-weight: bold; font-style: italic;">rng_a</span>, <span style="font-weight: bold; font-style: italic;">rng_b</span> = at.random.split(rng)
<span style="font-weight: bold; font-style: italic;">a_rv</span> = at.random.normal(rng_a, 0, 1)
<span style="font-weight: bold; font-style: italic;">b_rv</span> = at.random.normal(rng_b, 0, 1)

<span style="font-weight: bold; font-style: italic;">rngs</span> = at.random.split(rng, 10)
<span style="font-weight: bold; font-style: italic;">rvs</span> = []
<span style="font-weight: bold;">for</span> rng <span style="font-weight: bold;">in</span> rngs:
    rvs.append(at.random.normal(rng, 0, 1))
</pre>
</div>

<p>
How does that solve the previous issues?
</p>

<ol class="org-ol">
<li>Monkey patching to specialize the RV <code>Op</code>\s</li>
<li>RVs in S-expressions and rewrites</li>
</ol>

<p>
What does that complicate?
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">standard_normal</span>():

</pre>
</div>
</div>
</div>

<div id="outline-container-orgacd0147" class="outline-2">
<h2 id="orgacd0147">Links to this note</h2>
<div class="outline-text-2" id="text-orgacd0147">
<ul class="org-ul">
<li><a href="./20220729163627-aesara.html">Aesara</a></li>
<li><a href="./inbox.html">Writing inbox</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
