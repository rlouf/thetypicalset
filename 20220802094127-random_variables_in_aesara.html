<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-10-10 Mon 16:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Random Variables in Aesara</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Random Variables in Aesara</h1>
<ul class="org-ul">
<li><code>RandomGenerator</code></li>
<li><code>RandomState</code></li>
<li><code>RandomStream</code></li>
</ul>

<div id="outline-container-org13f6011" class="outline-2">
<h2 id="org13f6011">AeP (Aesara Enhancement Propoal)</h2>
<div class="outline-text-2" id="text-org13f6011">
</div>
<div id="outline-container-orgf68c9d8" class="outline-3">
<h3 id="orgf68c9d8">Guidelines</h3>
<div class="outline-text-3" id="text-orgf68c9d8">
<p>
A good PRNG design satisfies the following conditions:
</p>
<ol class="org-ol">
<li>It is <b><b>expressive</b></b>: the behavior of the system is <b><b>predictable</b></b> by the caller, and allows them to expression any probabilistic program they want;</li>
<li>Makes it possible to build <b><b>reproducible</b></b> programs ("seeding");</li>
<li>It enables <b><b>vectorization</b></b> with generalized universal functions;</li>
<li>It leaves the IR uncluttered, in particular it does not add sequencing constraints between function calls that have no data dependence;</li>
<li>It can be transpiled to any backend, past present and future;</li>
<li>It <b><b>fits in with Aesara's rewrite system</b></b>;</li>
<li>It <b><b>is explicit in Aesara's IR</b></b></li>
</ol>
</div>
</div>

<div id="outline-container-org80db55b" class="outline-3">
<h3 id="org80db55b">Limits of the current design</h3>
<div class="outline-text-3" id="text-org80db55b">
<p>
The current <code>RandomState</code> model threads the RNG state through all the functions that generate random values. This is how the <code>RandomState</code> API would look like with <code>default_output</code> set to <code>None</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">sample</span>(rng):

<span style="font-weight: bold; font-style: italic;">rng</span> = np.random.default_rng(12)
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(0, 1, rng=rng)
<span style="font-weight: bold; font-style: italic;">rng_y</span>, <span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(0, 1, rng=rng_x)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
This design is inconvenient to work with.
</p>
</div>

<ul class="org-ul">
<li><a id="org816d04e"></a>Error-prone and cumbersome<br />
<div class="outline-text-5" id="text-org816d04e">
<p>
<b>For users</b> having to explictly thread the <code>rng</code> states is both error-prone and cumbersome. I believe this is why the RNG output is hidden by setting <code>default_output</code> to <code>1</code>, and one of the motivations behind the <code>RandomStream</code> interface.
</p>
</div>
</li>

<li><a id="org1172dbd"></a>Adds sequencing constraints between functions that have no data dependence<br />
<div class="outline-text-5" id="text-org1172dbd">
<p>
<b>For the Aesara IR</b> the threading of RNGs adds sequencing constraints between functions that have no data dependence otherwise. In theory, the two calls to <code>at.random.normal</code> are independent and could be made in parallel. In practice, one has to wait for the first call to complete to be able to make the second all.
</p>

<p>
Same with gufuncs: we do not want to introduce rng-dependence between the different function calls. We want to be able to give each dimension (give example) a rng and let it run with it. No collision:
</p>
</div>
</li>

<li><a id="org092fa64"></a>Lack of a clear symbolic representation<br />
<div class="outline-text-5" id="text-org092fa64">
<p>
<b>For the Aesara IR</b> we don't have distinct operators that updates the random state and generate a pseudo-random number from a random state.
</p>

<p>
And finally this is not enought for the one-to-many problem in rewrites.
</p>

<p>
Only the caller knows how the random state should be managed as called functions are unaware of the context. The solution is very simple, it is to give the caller the responsibility of advancing the rng state. So functions do not need to return RNG state.
</p>

<p>
<i>Note:</i> Well, some function have to return the RNG state in JAX and it's the body function of while loops. Still goes to show how broken of an abstraction it is. There needs to pass RNG state because there <i>is</i> a data dependence between the two.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">sequential</span>(rng):
    <span style="font-weight: bold; font-style: italic;">rng_y</span>, <span style="font-weight: bold; font-style: italic;">rng_z</span> = at.random.split(rng, 2)
    <span style="font-weight: bold;">return</span> call(rng_y) + call(rng_z)

<span style="font-weight: bold; font-style: italic;">sequential_et</span> = etuple(
    etuplize(at.add),
    etuple(
        call,
        etuple(
            nth,
            0,
            etuple(
                etuplize(at.random.split),
                rng,
                2
            )
        )
    ),
    etuple(
        call,
        etuple(
            nth,
            1,
            etuple(
                etuplize(at.random.split),
                rng,
                2
            )
        )
    )
)
</pre>
</div>

<p>
<b>First</b> justify the <code>split</code>, <code>rand</code> symbolic interface (reference Haskell)
</p>


<p>
Counter based approach: <a target='_blank' rel='noopener noreferrer' class='external' href="http://www.thesalmons.org/john/random123/papers/random123sc11.pdf">Parallel Random Numbers: As easy as 1, 2, 3</a>
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org06db93c" class="outline-3">
<h3 id="org06db93c">Proposal: A Haskell-like design</h3>
<div class="outline-text-3" id="text-org06db93c">
<p>
In the following we will first focus on <i>the symbolic representation of RNGs in Aesara's IR</i>. We leave discussions about compilation of this representation for the end.
</p>

<p>
To begin with we need to distinguish between two objects that are conflated in Aesara:
</p>
<ul class="org-ul">
<li>The <code>RandomState</code> which is the current state of the random number generator;</li>
<li>The <code>RandomVariable</code>, which takes a <code>RandomState</code> and returns a pseudo-random number <code>Bit</code></li>
</ul>

<p>
The current design of <code>RandomVariable</code>\s in Aesara can be summarized by the following operator signature:
</p>

<p>
If we represent the internal state of the PRNG by the type <code>RandState</code>, the current design of <code>RandomVariable</code>\s can be summarized by the following simplified signature:
</p>

<div class="org-src-container">
<pre class="src src-haskell">RandomVariable :: RandState -&gt; (RandState, TensorVariable)
</pre>
</div>

<p>
In other words, <code>RandomVariable</code>\s are responsible for advancing the state of the PRNG, and produce a random value. This double responsibility is what creates graph dependencies between nodes that have otherwise no dependency i.e. that wouldn't be linked had they not needed the PRNG.
</p>
</div>

<div id="outline-container-orgbc457fe" class="outline-4">
<h4 id="orgbc457fe">New operators</h4>
<div class="outline-text-4" id="text-orgbc457fe">
<p>
A natural idea is to simplify the design of <code>RandomVariable</code>\s so that it is only responsible for one thing: create a random value from a PRNG state. The <code>Op</code> thus creates an <code>Apply</code> node that takes a <code>RandomState</code> as input and outputs a (random) <code>Variable</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">RandomVariable :: RandomState -&gt; Variable
</pre>
</div>

<p>
We can now make the <code>RandState</code> output explicit (1) by making <code>rng</code> an explicit input of the <code>RandomVariable</code>'s <code>__call__</code> method. And we can verify in the following that the sequential dependency between <code>x_rv</code> and <code>y_rv</code> disappears:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">rng_x and rng_y are created before that.</span>
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
</pre>
</div>

<p>
This interface presupposes the existence of an operator that creates an updated <code>RandomState</code> from a <code>RandomState</code>:
</p>

<div class="org-src-container">
<pre class="src src-haskell">next :: RandomState -&gt; RandomState
</pre>
</div>

<p>
To be able to build reproducible programs (2), we also need an operator that creates a <code>RandomState</code> from a seed:
</p>

<div class="org-src-container">
<pre class="src src-haskell">default_rng :: Seed -&gt; RandomState
</pre>
</div>

<p>
We can thus fill in the blanks in the previous code snippet:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng(0)

<span style="font-weight: bold; font-style: italic;">rng_x</span> = at.random.<span style="font-weight: bold;">next</span>(rng)
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)

<span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.<span style="font-weight: bold;">next</span>(rng_x)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)

<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
This code generates Aesara graphs that are very similar to the ones generated by <code>RandomStream</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">srng</span> = at.random.RandomStream()

<span style="font-weight: bold; font-style: italic;">x_rv</span> = srng.normal(0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = srng.normal(0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
Roughly speaking, <code>RandomStream</code> moves this "next" mechanism to the <i>updates</i> graph, while this symbolic representation of the state of the PRNG makes it explicit in the same graph. The graph between <code>RandomState</code>\s in the proposed scheme is a concretization of the updates graph for the <code>RandomStream</code>.
</p>

<p>
Let us now consider a more complex situation, when <code>call_x</code> and <code>call_y</code> are two functions that require a <code>RandomState</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng(0)

<span style="font-weight: bold; font-style: italic;">rng_x</span> = at.random.<span style="font-weight: bold;">next</span>(rng)
<span style="font-weight: bold; font-style: italic;">x_rv</span> = call_x(rng_x)

<span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.<span style="font-weight: bold;">next</span>(rng_x)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = call_y(rng_y)

<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
We can easily make the previous code generate a collision:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">call_x</span>(rng_a):
    <span style="font-weight: bold; font-style: italic;">a_rv</span> = at.random.normal(rng_a, 0, 1)
    <span style="font-weight: bold; font-style: italic;">rng_b</span> = at.random.<span style="font-weight: bold;">next</span>(rng_a)
    <span style="font-weight: bold; font-style: italic;">b_rv</span> = at.random.normal(rng_b, 0, 1)
    <span style="font-weight: bold;">return</span> a_rv * b_rv
</pre>
</div>

<p>
The issue arises because our symbolic structure is <i>linear</i>: each <code>RandState</code> has one and only one ancestor. What we need instead is to allow <code>RandState</code>\s to have several ancestors; We thus define the <code>at.random.op.Split</code> operator:
</p>

<div class="org-src-container">
<pre class="src src-haskell">split :: RandState -&gt; (RandState, RandState)
</pre>
</div>

<p>
This can be easily implemented: if <code>RandState</code> is a binary number &lt;..&gt; then the leftmost key is obtained by appending <code>0</code>, the rightmost <code>1</code>. Any succession of splitting operations builds a binary tree. If <code>Rand</code> is a deterministic function of this value, then the computations are fully reproducible. This binary tree structure is encoded directly in the graph IR:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng(0)
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.split(rng)

etuplize(rng_x)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">etuple(nth, 0, etuple(at.random.split, etuple(at.random.default_rng, 0)))</span>

etuplize(rng_y)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">etuple(nth, 1, etuple(at.random.split, etuple(at.random.default_rng, 0)))</span>
</pre>
</div>

<p>
Although it may be possible to keep <code>Next</code> within this representation, its interaction with the <code>Split</code> operator requires careful thought. We forget it for now, as <code>Split</code> is expressive enough. The original program becomes:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng()
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.split(rng)

<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv
</pre>
</div>

<p>
It is also natural to implement the <code>at.random.op.SplitN</code> operator represented by:
</p>

<div class="org-src-container">
<pre class="src src-haskell">splitn :: RandState -&gt; Int -&gt; (RandState, ..., RandState)
</pre>
</div>

<p>
So we can write the following code:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">at.random.split</span> = at.random.Split()

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng()
<span style="font-weight: bold; font-style: italic;">rng_v</span>, <span style="font-weight: bold; font-style: italic;">rng_w</span>, <span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.splitn(rng, 4)

<span style="font-weight: bold; font-style: italic;">v_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">w_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = v_rv + w_rv + x_rv + z_rv
</pre>
</div>

<p>
This will prove useful e.g. for use with generalized universal functions.
</p>
</div>
</div>

<div id="outline-container-org1abd71b" class="outline-4">
<h4 id="org1abd71b">Etuplization</h4>
<div class="outline-text-4" id="text-org1abd71b">
<p>
These new operators simplify greatly the work with etuplized versions of graphs with random variables. Assuming we have a <code>Nth</code> operator in Aesara as well:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> etuples <span style="font-weight: bold;">import</span> ExpressionTuple, etuplize
<span style="font-weight: bold;">from</span> aesara.graph.rewriting.unify <span style="font-weight: bold;">import</span> OpExpressionTuple

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.default_rng()
<span style="font-weight: bold; font-style: italic;">rng_x</span>, <span style="font-weight: bold; font-style: italic;">rng_y</span> = at.random.split(rng)
<span style="font-weight: bold; font-style: italic;">x_rv</span> = at.random.normal(rng_x, 0, 1)
<span style="font-weight: bold; font-style: italic;">y_rv</span> = at.random.normal(rng_y, 0, 1)
<span style="font-weight: bold; font-style: italic;">z_at</span> = x_rv + y_rv

<span style="font-weight: bold; font-style: italic;">z_et</span> = OpExpressionTuple(
    etuplize(at.add),
    OpExpressionTuple(
        etuplize(at.random.normal),
        ExpressionTuple(
           etuplize(aesara.graph.nth),
           1,
           OpExpressionTuple(
               etuplize(at.random.split)
               rng
           )
        ),
        0,
        1,
        size,
        dtype,
    ),
    OpExpressionTuple(
        etuplize(at.random.normal),
        ExpressionTuple(
           etuplize(aesara.graph.nth),
           0,
           OpExpressionTuple(
               etuplize(at.random.split)
               rng
           )
        ),
        0,
        1,
        size,
        dtype,
    ),
)
</pre>
</div>

<p>
This solves the one-to-many problem we had for mixtures. If we have a relation between a single random variable and two we can now write:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">z_et</span> = etuple(etuplize(at.random.normal), rng_lv, size_lv, dtype_lv, at.as_tensor(1.), at.as_tensor(2.))

<span style="font-weight: bold; font-style: italic;">sum_et</span> = etuple(
    etuplize(at.add),
    etuple(
        etuplize(at.random.normal),
        etuple(
            etuplize(at.graph.nth),
            0,
            etuple(
                etuplize(at.random.split),
                rng_lv,
            )
        )
        size_lv,
        dtype_lv,
        at.as_tensor(0.),
        at.as_tensor(1.),
    ),
    etuple(
        etuplize(at.random.normal),
        etuple(
            etuplize(at.graph.nth),
            1,
            etuple(
                etuplize(at.random.split),
                rng_lv,
            )
        )
        size_lv,
        dtype_lv,
        at.as_tensor(0.),
        at.as_tensor(1.),
    )
)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge517654" class="outline-4">
<h4 id="orge517654">Behavior under transpilation</h4>
<div class="outline-text-4" id="text-orge517654">
</div>
<ul class="org-ul">
<li><a id="org7146d3e"></a>JAX<br />
<div class="outline-text-5" id="text-org7146d3e">
<p>
Straightforward, the behavior is similar.
</p>
</div>
</li>

<li><a id="org3573635"></a>Numba<br />
<div class="outline-text-5" id="text-org3573635">
<p>
Numba has primitive support for NumPy's Generator.
</p>
</div>
</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-org48b17c9" class="outline-2">
<h2 id="org48b17c9">RandomVariable Ops</h2>
<div class="outline-text-2" id="text-org48b17c9">
<p>
We have a <code>default_rng</code> function, but the result does not behave as a generator in <code>numpy</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> default_rng
<span style="font-weight: bold; font-style: italic;">rng</span> = default_rng(32)
rng.<span style="font-weight: bold;">type</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.tensor.random.basic <span style="font-weight: bold;">import</span> NormalRV

<span style="font-weight: bold; font-style: italic;">norm</span> = NormalRV()
<span style="font-weight: bold; font-style: italic;">norm_rv</span> = norm(0, 1, size=(2,), rng=rng)

norm_rv.<span style="font-weight: bold;">eval</span>()
</pre>
</div>


<p>
<code>Aesara</code> also defines aliases for the <code>RandomVariable</code> Ops:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> normal

<span style="font-weight: bold; font-style: italic;">normal_rv</span> = normal(0, 1, size=(2,), rng=rng)
normal_rv.<span style="font-weight: bold;">eval</span>()
</pre>
</div>

<p>
Let's look at the graphs that are produced:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara
<span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> default_rng, normal

<span style="font-weight: bold; font-style: italic;">rng</span> = default_rng(0)
<span style="font-weight: bold; font-style: italic;">a_rv</span> = normal(0, 1, rng=rng)
<span style="font-weight: bold; font-style: italic;">b_rv</span> = normal(0, 1, rng=rng)
<span style="font-weight: bold; font-style: italic;">c_tt</span> = a_rv + b_rv

<span style="font-weight: bold; font-style: italic;">d_rv</span> = normal(0, 1, rng=rng)

aesara.dprint(c_tt * d_rv)
</pre>
</div>


<p>
How does <code>RandomGeneratorType</code> work? It looks like it has internal state.
</p>
</div>
</div>

<div id="outline-container-org1a326ab" class="outline-2">
<h2 id="org1a326ab">Define custom random variables</h2>
<div class="outline-text-2" id="text-org1a326ab">
<p>
It is fairly simple as <code>srng.gen(RV, *args)</code> will call <code>RV()(random_state, *args)</code>.
</p>

<div class="org-src-container">
<pre class="src src-python">srng.gen(zero_truncated_betabinom, eta_at, kappa_rv, n_at),
</pre>
</div>

<p>
where the <code>RandomVariable</code> is implemented as:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">ZeroTruncatedBetaBinomial</span>(RandomVariable):
    r<span style="font-style: italic;">"""A zero-truncated beta-binomial distribution.</span>

<span style="font-style: italic;">    This distribution is implemented in the :math:`\kappa`</span>
<span style="font-style: italic;">    and :math:`\eta` parameterization, which is related to</span>
<span style="font-style: italic;">    the standard :math:`\alpha` and :math:`\beta` parameterization</span>
<span style="font-style: italic;">    of the beta-binomial through the following:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \alpha = \eta / \kappa \\</span>
<span style="font-style: italic;">        \beta = (1 - \eta) / \kappa</span>

<span style="font-style: italic;">    Truncation aside, for a :math:`Y \sim \operatorname{BetaBinom}\left(N, \eta, \kappa\right)`,  # noqa: E501</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \operatorname{E}\left[ Y \right] = N \eta \\</span>
<span style="font-style: italic;">        \operatorname{Var}\left[ Y \right] = N \eta (1 - \eta) (N \kappa + 1) / (\kappa + 1)</span>


<span style="font-style: italic;">    Under this parameterization, :math:`\kappa` in the standard beta-binomial</span>
<span style="font-style: italic;">    serves as an over-dispersion term with the following properties:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \lim_{\kappa \to 0} \operatorname{Var}\left[ Y \right] = N \eta (1 - \eta) \\</span>
<span style="font-style: italic;">        \lim_{\kappa \to \infty} \operatorname{Var}\left[ Y \right] = N^2 \eta (1 - \eta)</span>

<span style="font-style: italic;">    In other words, :math:`\kappa` modulates between the standard binomial</span>
<span style="font-style: italic;">    variance and :math:`N`-times that variance.</span>

<span style="font-style: italic;">    The un-truncated probability mass function (PMF) is as follows:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \frac{\operatorname{B}\left(\frac{\eta}{\kappa} + y, n - y + \frac{1 - \eta}{\kappa}\right) {\binom{n}{y}}}{\operatorname{B}\left(\frac{\eta}{\kappa}, \frac{1 - \eta}{\kappa}\right)}  # noqa: E501</span>

<span style="font-style: italic;">    and the zero-truncated PMF is as follows:</span>

<span style="font-style: italic;">    .. math::</span>
<span style="font-style: italic;">        \frac{\operatorname{B}\left(\frac{\eta}{\kappa} + y, - \frac{\eta}{\kappa} + n - y + \frac{1}{\kappa}\right) {\binom{n}{y}}}{\operatorname{B}\left(\frac{\eta}{\kappa}, - \frac{\eta}{\kappa} + \frac{1}{\kappa}\right) - \operatorname{B}\left(\frac{\eta}{\kappa}, - \frac{\eta}{\kappa} + n + \frac{1}{\kappa}\right)}  # noqa: E501</span>

<span style="font-style: italic;">    """</span>
    <span style="font-weight: bold; font-style: italic;">name</span> = <span style="font-style: italic;">"zero_truncated_betabinom"</span>
    <span style="font-weight: bold; font-style: italic;">ndim_supp</span> = 0
    <span style="font-weight: bold; font-style: italic;">ndims_params</span> = [0, 0, 0]
    <span style="font-weight: bold; font-style: italic;">dtype</span> = <span style="font-style: italic;">"int64"</span>
    <span style="font-weight: bold; font-style: italic;">_print_name</span> = (<span style="font-style: italic;">"ZeroTruncBetaBinom"</span>, <span style="font-style: italic;">"\\operatorname{BetaBinom}_{&gt;0}"</span>)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, rejection_threshold=200, **kwargs):
        <span style="font-style: italic;">"""</span>
<span style="font-style: italic;">        Parameters</span>
<span style="font-style: italic;">        ----------</span>
<span style="font-style: italic;">        rejection_threshold</span>
<span style="font-style: italic;">            The number of rejection iterations to perform before raising an</span>
<span style="font-style: italic;">            exception.</span>
<span style="font-style: italic;">        """</span>
        <span style="font-weight: bold;">self</span>.rejection_threshold = rejection_threshold
        <span style="font-weight: bold;">super</span>().__init__(**kwargs)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__call__</span>(<span style="font-weight: bold;">self</span>, eta, kappa, n, size=<span style="font-weight: bold; text-decoration: underline;">None</span>, **kwargs):
        <span style="font-style: italic;">"""</span>
<span style="font-style: italic;">        Parameters</span>
<span style="font-style: italic;">        ----------</span>
<span style="font-style: italic;">        eta</span>
<span style="font-style: italic;">        kappa</span>
<span style="font-style: italic;">        n</span>
<span style="font-style: italic;">        """</span>

        <span style="font-weight: bold;">self</span>.eta = at.as_tensor_variable(eta, dtype=aesara.config.floatX)
        <span style="font-weight: bold;">self</span>.kappa = at.as_tensor_variable(kappa, dtype=aesara.config.floatX)
        <span style="font-weight: bold;">self</span>.n = at.as_tensor_variable(n, dtype=np.int64)

        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">super</span>().__call__(eta, kappa, n, size=size, **kwargs)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">rng_fn</span>(<span style="font-weight: bold;">self</span>, rng, eta, kappa, n, size):
        <span style="font-style: italic;">"""A naive hybrid rejection + inverse sampler."""</span>

        <span style="font-weight: bold; font-style: italic;">n</span> = np.asarray(n, dtype=np.int64)
        <span style="font-weight: bold; font-style: italic;">eta</span> = np.asarray(eta, dtype=np.float64)
        <span style="font-weight: bold; font-style: italic;">kappa</span> = np.asarray(kappa, dtype=np.float64)

        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Values below this will produce errors (plus, it means this is really</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">a binomial)</span>
        <span style="font-weight: bold; font-style: italic;">alpha</span> = np.clip(eta / kappa, near_zero, 1e100)
        <span style="font-weight: bold; font-style: italic;">beta</span> = np.clip((1 - eta) / kappa, near_zero, 1e100)

        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">def zt_bb_inv(n, alpha, beta, size=None):</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">"""A zero-truncated beta-binomial inverse sampler."""</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;"># bb_dist = scipy.stats.betabinom(n, alpha, beta)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">beta_smpls = np.clip(</span>
        <span style="font-weight: bold; font-style: italic;">#         </span><span style="font-weight: bold; font-style: italic;">scipy.stats.beta(alpha, beta).rvs(size=size), 1e-10, np.inf</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">binom_dist = scipy.stats.binom(n, beta_smpls)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">u = np.random.uniform(size=size)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">F_0 = binom_dist.cdf(0)</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">samples = binom_dist.ppf(F_0 + u * (1 - F_0))</span>
        <span style="font-weight: bold; font-style: italic;">#     </span><span style="font-weight: bold; font-style: italic;">return samples</span>

        <span style="font-weight: bold; font-style: italic;">samples</span> = scipy.stats.betabinom(n, alpha, beta).rvs(size=size, random_state=rng)
        <span style="font-weight: bold; font-style: italic;">alpha</span> = np.broadcast_to(alpha, samples.shape)
        <span style="font-weight: bold; font-style: italic;">beta</span> = np.broadcast_to(beta, samples.shape)
        <span style="font-weight: bold; font-style: italic;">n</span> = np.broadcast_to(n, samples.shape)
        <span style="font-weight: bold; font-style: italic;">rejects</span> = samples &lt;= 0

        <span style="font-weight: bold; font-style: italic;">thresh_count</span> = 0
        <span style="font-weight: bold;">while</span> rejects.<span style="font-weight: bold;">any</span>():
            <span style="font-weight: bold; font-style: italic;">_n</span> = n[rejects] <span style="font-weight: bold;">if</span> np.size(n) &gt; 1 <span style="font-weight: bold;">else</span> n
            <span style="font-weight: bold; font-style: italic;">_alpha</span> = alpha[rejects] <span style="font-weight: bold;">if</span> np.size(alpha) &gt; 1 <span style="font-weight: bold;">else</span> alpha
            <span style="font-weight: bold; font-style: italic;">_beta</span> = beta[rejects] <span style="font-weight: bold;">if</span> np.size(beta) &gt; 1 <span style="font-weight: bold;">else</span> beta
            <span style="font-weight: bold; font-style: italic;">_size</span> = rejects.<span style="font-weight: bold;">sum</span>()

            <span style="font-weight: bold; font-style: italic;">beta_smpls</span> = np.clip(
                scipy.stats.beta(_alpha, _beta).rvs(size=_size, random_state=rng),
                near_zero,
                near_one,
            )
            <span style="font-weight: bold; font-style: italic;">samples</span>[rejects] = scipy.stats.binom(_n, beta_smpls).rvs(
                size=_size, random_state=rng
            )
            <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">samples[rejects] = scipy.stats.betabinom(_n, _alpha, _beta).rvs(size=_size)  # noqa: E501</span>

            <span style="font-weight: bold; font-style: italic;">new_rejects</span> = samples &lt;= 0
            <span style="font-weight: bold;">if</span> new_rejects.<span style="font-weight: bold;">sum</span>() == rejects.<span style="font-weight: bold;">sum</span>():
                <span style="font-weight: bold;">if</span> thresh_count &gt; <span style="font-weight: bold;">self</span>.rejection_threshold:
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;"># Attempt rejection sampling until the rejection results</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;"># get stuck, then use the inverse-sampler</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">samples[rejects] = zt_bb_inv(_n, _alpha, _beta, size=_size)</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">break</span>
                    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">raise ValueError("The sampling rejection threshold was met")</span>
                    warnings.warn(
                        <span style="font-style: italic;">"The sampling rejection threshold was met "</span>
                        <span style="font-style: italic;">"and mean values were used as sample values"</span>
                    )
                    <span style="font-weight: bold; font-style: italic;">sp_ref_dist</span> = scipy.stats.betabinom(_n, _alpha, _beta)
                    <span style="font-weight: bold; font-style: italic;">trunc_mean</span> = sp_ref_dist.mean() / (1 - sp_ref_dist.cdf(0))
                    <span style="font-weight: bold;">assert</span> np.<span style="font-weight: bold;">all</span>(trunc_mean &gt;= 1)
                    <span style="font-weight: bold; font-style: italic;">samples</span>[rejects] = trunc_mean
                    <span style="font-weight: bold;">break</span>
                <span style="font-weight: bold;">else</span>:
                    <span style="font-weight: bold; font-style: italic;">thresh_count</span> += 1
            <span style="font-weight: bold;">else</span>:
                <span style="font-weight: bold; font-style: italic;">thresh_count</span> = 0

            <span style="font-weight: bold; font-style: italic;">rejects</span> = new_rejects

        <span style="font-weight: bold;">return</span> samples


<span style="font-weight: bold; font-style: italic;">zero_truncated_betabinom</span> = ZeroTruncatedBetaBinomial()


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">_logp</span>(value, eta, kappa, n):
    <span style="font-weight: bold;">return</span> (
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">binomln(n, value)</span>
        -at.log(n + 1)
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- betaln(n - value + 1, value + 1)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">+ betaln(value + alpha, n - value + beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- betaln(alpha, beta)</span>
        - at.gammaln(n - value + 1)
        - at.gammaln(value + 1)
        + at.gammaln(n + 2)
        + at.gammaln(value + eta / kappa)
        + at.gammaln(n - value + (1 - eta) / kappa)
        - at.gammaln(1 / kappa + n)
        - at.gammaln(eta / kappa)
        - at.gammaln((1 - eta) / kappa)
        + at.gammaln(1 / kappa)
    )


<span style="font-weight: bold; text-decoration: underline;">@_logprob.register</span>(ZeroTruncatedBetaBinomial)
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">zero_truncated_betabinom_logprob</span>(op, values, *inputs, **kwargs):
    (values,) = values
    (eta, kappa, n) = inputs[3:]

    <span style="font-weight: bold; font-style: italic;">l0</span> = (
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">gammaln(alpha + beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">+ gammaln(n + beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- gammaln(beta)</span>
        <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">- gammaln(alpha + beta + n)</span>
        at.gammaln(1 / kappa)
        + at.gammaln(n + (1 - eta) / kappa)
        - at.gammaln((1 - eta) / kappa)
        - at.gammaln(1 / kappa + n)
    )

    <span style="font-weight: bold; font-style: italic;">log1mP0</span> = at.log1mexp(l0)
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">log1mP0 = 0</span>

    <span style="font-weight: bold; font-style: italic;">res</span> = CheckParameterValue(<span style="font-style: italic;">"values &lt;= n, eta &gt; 0, kappa &gt; 0"</span>)(
        at.switch(values &gt; 0, _logp(values, eta, kappa, n) - log1mP0, -np.inf),
        at.<span style="font-weight: bold;">all</span>(values &lt;= n),
        at.<span style="font-weight: bold;">all</span>(eta &gt; 0),
        at.<span style="font-weight: bold;">all</span>(kappa &gt; 0),
    )
    <span style="font-weight: bold;">return</span> res
</pre>
</div>

<p>
Note that you can also define this random variables' logprob dispatching <code>_logprob</code> for the <code>ZeroTruncBetaBinom</code>.
</p>
</div>
</div>

<div id="outline-container-org2254326" class="outline-2">
<h2 id="org2254326">Sampling vs Logprobability <code>aeppl</code></h2>
<div class="outline-text-2" id="text-org2254326">
<ul class="org-ul">
<li>How define the logprob of a custom distribution?</li>
</ul>
</div>
</div>

<div id="outline-container-orgce19e8c" class="outline-2">
<h2 id="orgce19e8c">Shapes</h2>
<div class="outline-text-2" id="text-orgce19e8c">
<p>
Shapes are always a mess when it comes to random variables. In <code>aesara</code> we note two distinct shapes:
</p>
<ul class="org-ul">
<li><code>ndim_supp</code> the number of dimensions of the RV's support.</li>
<li><code>ndim_params</code></li>
<li><code>size</code> which is the sample size</li>
</ul>

<p>
Remember that shapes in Aesara can be determined at runtime! So if we assume that:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">batch_shape</span> = size
np.ndim(sample_shape) = ndim_supp
<span style="font-weight: bold; font-style: italic;">shape</span> = sample_shape + batch_shape
</pre>
</div>

<p>
And we should have a look at broadcasting rules because they are not all very obvious.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at
<span style="font-weight: bold;">from</span> aesara.tensor.random <span style="font-weight: bold;">import</span> RandomStream

<span style="font-weight: bold; font-style: italic;">srng</span> = RandomStream(0)
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.normal(0, 1, size=(2,3))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">mu</span> = at.as_tensor([1., 2., 3.])
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.normal(mu, 1, size=(2,3))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>())
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">mu</span> = at.as_tensor([1., 2.])
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.normal(mu, 1, size=(2,3))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>())
</pre>
</div>

<p>
More complex is the case where the random variable is non-scalar, as multivariate normal. Here you can see that the "event shape" is equal to 2. The resulting shape, if we assume <code>event_shape</code> and <code>batch_shape</code> are tuples is given by:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">shape</span> = event_shape + batch_shape
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np

<span style="font-weight: bold; font-style: italic;">mu</span> = np.r_[1, 2]
<span style="font-weight: bold; font-style: italic;">sigma</span> = np.array([[.5, .5], [.4, .6]])
<span style="font-weight: bold; font-style: italic;">a_rv</span> = srng.multivariate_normal(mu, sigma, size=(2, 5))
<span style="font-weight: bold;">print</span>(a_rv.<span style="font-weight: bold;">eval</span>().shape)
</pre>
</div>

<p>
See <a target='_blank' rel='noopener noreferrer' class='external' href="https://ericmjl.github.io/blog/2019/5/29/reasoning-about-shapes-and-probability-distributions/">Eric Ma's blog post on the topic</a>.
</p>
</div>
</div>

<div id="outline-container-orge9bfdac" class="outline-2">
<h2 id="orge9bfdac">Problems with <code>RandomStream</code></h2>
<div class="outline-text-2" id="text-orge9bfdac">
<p>
<a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aesara/pull/1211#discussion_r985057882">https://github.com/aesara-devs/aesara/pull/1211#discussion_r985057882</a>
</p>
</div>
</div>

<div id="outline-container-org13604d8" class="outline-2">
<h2 id="org13604d8">Proposal</h2>
<div class="outline-text-2" id="text-org13604d8">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> aesara.tensor <span style="font-weight: bold;">as</span> at

<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.RandomState()

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">RandomVariables divide the rng</span>
<span style="font-weight: bold; font-style: italic;">a_rv</span>, <span style="font-weight: bold; font-style: italic;">rng</span> = at.random.normal(rng, 0, 1)
<span style="font-weight: bold; font-style: italic;">b_rv</span>, <span style="font-weight: bold; font-style: italic;">_</span> = at.random.normal(rng, 0, 1)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We have to update the rng manually</span>
<span style="font-weight: bold; font-style: italic;">a_rv</span> = at.random.normal(rng, 0, 1)
<span style="font-weight: bold; font-style: italic;">rng</span> = at.random.update(rng)
<span style="font-weight: bold; font-style: italic;">b_rv</span> = at.random.normal(rng, 0, 1)

<span style="font-weight: bold; font-style: italic;">rng_a</span>, <span style="font-weight: bold; font-style: italic;">rng_b</span> = at.random.split(rng)
<span style="font-weight: bold; font-style: italic;">a_rv</span> = at.random.normal(rng_a, 0, 1)
<span style="font-weight: bold; font-style: italic;">b_rv</span> = at.random.normal(rng_b, 0, 1)

<span style="font-weight: bold; font-style: italic;">rngs</span> = at.random.split(rng, 10)
<span style="font-weight: bold; font-style: italic;">rvs</span> = []
<span style="font-weight: bold;">for</span> rng <span style="font-weight: bold;">in</span> rngs:
    rvs.append(at.random.normal(rng, 0, 1))
</pre>
</div>

<p>
How does that solve the previous issues?
</p>

<ol class="org-ol">
<li>Monkey patching to specialize the RV <code>Op</code>\s</li>
<li>RVs in S-expressions and rewrites</li>
</ol>

<p>
What does that complicate?
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">standard_normal</span>():

</pre>
</div>
</div>
</div>

<div id="outline-container-orge9888bb" class="outline-2">
<h2 id="orge9888bb">Links to this note</h2>
<div class="outline-text-2" id="text-orge9888bb">
<ul class="org-ul">
<li><a href="./20220729163627-aesara.html">Aesara</a></li>
<li><a href="./inbox.html">Writing inbox</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
