<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-08-30 Tue 22:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>condp</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">condp</h1>
<blockquote>
<p>
The designers of search-based programming tools strive to find a balance between making a tool that is easy to use, and one that models the smart ways in which humans approach problems. Without <code>condp</code>, miniKanren achieves the first goal, and <code>condp</code>, only adding the work of a few small suggestion functions, brings miniKanren closer to achieving the second goal.
</p>
</blockquote>

<p>
<code>miniKanren</code> works with an interleaving depth-first search. Each disjunct operator (including <code>conde</code>) creates a new branch that has to be fully explored. As a result the search-space grows exponentially with the size of the problem. The way the search is interleaved can be substantially improves, and the authors proposed an replacement for <code>conde</code> where users can indicate which branch can be pre-emptively pruned. Humans are not only able to describe a problem relationally (like a <a href="blog/solve-sudokus-kanren.html">sudoku grid</a>), but also what a reasonable search strategy looks like. The current naive search strategy is what is problematic with <code>miniKanren</code>, but this can be easily solved.
</p>

<p>
The current implementation of <code>conde</code> in <code>kanren</code> calls the following function where the interleaving is implemented using <code>toolz</code>'s <code>interleaving</code>. This is the part that is targeted by <code>condp</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">ldisj_seq</span>(goals: Iterable[GoalType]) -&gt; GoalType:
    <span style="font-style: italic;">"""Produce a goal that returns the appended state stream from all successful goal arguments.</span>
<span style="font-style: italic;">    In other words, it behaves like logical disjunction/OR for goals.</span>
<span style="font-style: italic;">    """</span>  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">noqa: E501</span>

    <span style="font-weight: bold;">if</span> length_hint(goals, -1) == 0:
        <span style="font-weight: bold;">return</span> succeed

    <span style="font-weight: bold;">assert</span> <span style="font-weight: bold;">isinstance</span>(goals, Iterable)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">ldisj_seq_goal</span>(S: StateType) -&gt; StateStreamType:
        <span style="font-weight: bold;">nonlocal</span> goals

        <span style="font-weight: bold; font-style: italic;">goals</span>, <span style="font-weight: bold; font-style: italic;">_goals</span> = tee(goals)

        <span style="font-weight: bold;">yield</span> <span style="font-weight: bold;">from</span> interleave(g(S) <span style="font-weight: bold;">for</span> g <span style="font-weight: bold;">in</span> _goals)

    <span style="font-weight: bold;">return</span> ldisj_seq_goal

</pre>
</div>

<blockquote>
<p>
<code>condp</code> allows users to perform <i>partial reification</i> mid-computation, which applies the current substitutions but leaves the underlying representation of fresh variables in the resulting values. This allows <code>condp</code> lines to be pruned when they are guaranteed to fail, while freshness of variables remains known.
</p>
</blockquote>

<p>
This allows user to specify flexible search structures. Authors use the example of <code>Pie</code>, a dependent-type library which is complex enough to reach <code>conde</code>'s limitations.
</p>

<div id="outline-container-orga7bfcc4" class="outline-2">
<h2 id="orga7bfcc4">Suggestion functions</h2>
<div class="outline-text-2" id="text-orga7bfcc4">
<p>
The user passes <i>suggestion functions</i> to <code>condp</code> that can tell miniKanren which lines of <code>condp</code> are relevant or not.
</p>

<blockquote>
<p>
The goal when designing suggestion functions is to convey how search would be performed by hand.
</p>
</blockquote>

<p>
Functions are implemented in the host language (here python), and it is thus possible to use logic that is not available to miniKanren.
</p>

<ul class="org-ul">
<li>Conditional branches are given a label;</li>
<li>Suggestion functions take the current state and return labels;</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">_ls_keys</span>(ls):
    <span style="font-weight: bold;">if</span> isvar(ls):
        <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"use-maybe"</span>,)
    <span style="font-weight: bold;">elif</span> <span style="font-weight: bold;">isinstance</span>(ls, ConsNull):
        <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"BASE"</span>,)
    <span style="font-weight: bold;">elif</span> <span style="font-weight: bold;">isinstance</span>(ls, ConsPair):
        <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"KEEP"</span>, <span style="font-style: italic;">"SWAP"</span>)
    <span style="font-weight: bold;">else</span>:
        <span style="font-weight: bold;">return</span> ()

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">_o_keys</span>(o):
    <span style="font-weight: bold;">if</span> isvar(o):
        <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"BASE"</span>, <span style="font-style: italic;">"KEEP"</span>, <span style="font-style: italic;">"SWAP"</span>)
    <span style="font-weight: bold;">elif</span> <span style="font-weight: bold;">isinstance</span>(o, ConsNull):
        <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"BASE"</span>,)
    <span style="font-weight: bold;">elif</span> <span style="font-weight: bold;">isinstance</span>(o, ConsPair):
        <span style="font-weight: bold;">if</span> isvar(car(o)) <span style="font-weight: bold;">or</span> <span style="font-style: italic;">"novel"</span> == car(o):
            <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"KEEP"</span>, <span style="font-style: italic;">"SWAP"</span>)
        <span style="font-weight: bold;">else</span>:
            <span style="font-weight: bold;">return</span> (<span style="font-style: italic;">"KEEP"</span>,)
    <span style="font-weight: bold;">else</span>:
        <span style="font-weight: bold;">return</span> ()

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">swap_somep</span>(ls, o):
    <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">d</span>, <span style="font-weight: bold; font-style: italic;">res</span> = var(), var(), var()
    <span style="font-weight: bold; font-style: italic;">res</span> = condp(
        ((_ls_keys, ls), (_o_keys, o)),
        {
            <span style="font-style: italic;">"BASE"</span>: (nullo(ls), nullo(o)),
            <span style="font-style: italic;">"KEEP"</span>: (
                eq(cons(a, d), ls),
                eq(cons(a, res), o),
                Zzz(swap_somep, d, res),
            ),
            <span style="font-style: italic;">"SWAP"</span>: (
                eq(cons(a, d), ls),
                eq(cons(<span style="font-style: italic;">"novel"</span>, res), o),
                Zzz(swap_somep, d, res),
            ),
        },
    )
    <span style="font-weight: bold;">return</span> res

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">swap_someo</span>(ls, o):
    <span style="font-style: italic;">"""The original `conde` version."""</span>
    <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">d</span>, <span style="font-weight: bold; font-style: italic;">res</span> = var(), var(), var()
    <span style="font-weight: bold;">return</span> conde(
        [nullo(ls), nullo(o)],
        [eq(cons(a, d), ls), eq(cons(a, res), o), Zzz(swap_someo, d, res)],
        [eq(cons(a, d), ls), eq(cons(<span style="font-style: italic;">"novel"</span>, res), o), Zzz(swap_someo, d, res)],
    )
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a48ac9" class="outline-2">
<h2 id="org8a48ac9">Links to this note</h2>
<div class="outline-text-2" id="text-org8a48ac9">
<ul class="org-ul">
<li><a href="./20220804135950-minikanren.html">miniKanren</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
