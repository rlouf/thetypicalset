<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-02-02 Thu 11:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Estimer le report des voix aux présidentielles</title>
<meta name="author" content="Rémi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Estimer le report des voix aux présidentielles</h1>
<p>
Cet article fait suite au <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/laurentperrinet/2022-05-04_transfert-des-voix/blob/main/2022-06-08_transfert-des-voix.ipynb">travail de Laurent Perrinet</a> sur les reports de voix entre le premier et le deuxième tour des élections présidentielles en 2022. La démarche de ce travail est intéressante (et autant que je sache originale) : elle consiste à prendre les résultats des élections au niveau des bureaux de vote aux deux tours, et essayer d'estimer la probabilité que quelqu'un ayant voté pour X (par exemple Fabien Roussel) vote pour Y (par exemple Marine Le Pen) au second tour.
</p>

<p>
Le modèle utilisé est déterministe. Il suppose les résultats des premier et second tour connus et cherche à estimer la valeurs des éléments d'une matrice \(M\) de transition:
</p>

\begin{align*}
M_{i} &= \operatorname{Softmax}\left(\tilde{M}_{i}\right) \qquad \forall i = 1 \dots N_1\; \text{lignes}\\
p_2 &= p_1\,M\\
\end{align*}

<p>
où la somme des éléments de chaque ligne de la matrice \(M\) est contrainte et égale à 1; En réalité on cherche la valeur des élements de la matrice non constrainte \(\tilde{M}\) en utilisant un algorithme d'optimisation. L'expression du modèle ainsi que les résultats de l'article sus-cités suggèrent plusieurs pistes d'amélioration :
</p>

<ul class="org-ul">
<li>Lorsqu'on le verra plus loin, les distributions marginales \(P\left(Y_2 | X_1\right)\) sont très étalées. Or le modèle n'est pas probabiliste et ne retourne qu'une seule valeur; Un <i>modèle bayésien</i> correctement calibré permettrait a priori de rendre compte de l'étalement de ces distributions;</li>
<li>L'hypothèse d'une matrice unique pour tout le territoire est peut-être suffisante, mais elle est osée. On pourrait envisager un <i>modèle hiérarchique</i>, où l'on apprend une matrice par territoire mais ou une certaine information est partagée entre les territoires.</li>
<li>À l'échelle nationale, les sondages de sortie d'urne peuvent servir à informer les <i>distributions a priori</i> des probabilités de transition.</li>
</ul>

<p>
On se placera ici à l'échelle de la circonscription législative. Le découpage à l'échelle du bureau de vote est intéressant, mais le but implicite de cette étude est de donner une idée des reports de voix pour le second tour des législatives 2022 (et permet d'itérer rapidement sur un modèle de taille raisonnable). J'utilise ici le code de <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/laurentperrinet/2022-05-04_transfert-des-voix/blob/main/2022-06-08_transfert-des-voix.ipynb">Laurent Perrinet</a> en le modifiant (les erreurs éventuelles sont de mon fait).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> os
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np
<span style="color: #F0DFAF; font-weight: bold;">import</span> pandas <span style="color: #F0DFAF; font-weight: bold;">as</span> pd
</pre>
</div>

<div id="outline-container-org7feaa85" class="outline-2">
<h2 id="org7feaa85"><span class="todo TODO">TODO</span> Refactor the code a little bit</h2>
<div class="outline-text-2" id="text-org7feaa85">
</div>
<div id="outline-container-orgb23b69a" class="outline-3">
<h3 id="orgb23b69a"><span class="todo TODO">TODO</span> No one cares about the data downloading, hide</h3>
</div>
<div id="outline-container-org124a0c5" class="outline-3">
<h3 id="org124a0c5"><span class="todo TODO">TODO</span> Factor the plotting code into functions</h3>
</div>
<div id="outline-container-org469fd4b" class="outline-3">
<h3 id="org469fd4b"><span class="todo TODO">TODO</span> Factor the sampling code into functions</h3>
</div>
</div>

<div id="outline-container-org8e27a7f" class="outline-2">
<h2 id="org8e27a7f">Les données</h2>
<div class="outline-text-2" id="text-org8e27a7f">
<p>
Les résultats des élections présidentielles 2022 sont publiquement disponibles à l'échelle des circonscriptions législatives sous format <code>xlsx</code>. On utilise la librairies python <code>pandas</code> pour les manipuler et convertir dans le format approprié pour le modèle.
</p>
</div>

<div id="outline-container-org5ed7e16" class="outline-3">
<h3 id="org5ed7e16">Premier tour</h3>
<div class="outline-text-3" id="text-org5ed7e16">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fname</span> = <span style="color: #CC9393;">'/tmp/T1.xlsx'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> os.path.isfile(fname):
    <span style="color: #DFAF8F;">url</span> = <span style="color: #CC9393;">"https://www.data.gouv.fr/fr/datasets/r/1a35594a-99f2-4257-87e0-ec2f55039276"</span>
    <span style="color: #F0DFAF; font-weight: bold;">import</span> urllib.request
    urllib.request.urlretrieve(url, fname)

<span style="color: #DFAF8F;">T1</span> = pd.read_excel(fname)
</pre>
</div>

<p>
On vérifie que les données ont été bien téléchargées et converties:
</p>

<div class="org-src-container">
<pre class="src src-python">T1.tail()
</pre>
</div>

<p>
On regroupe les abstentions, votes blancs et nuls sous la catégorie des votes non-exprimés, et on formatte le nom des circonscriptions
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">df_1</span> = T1[[<span style="color: #CC9393;">'Nuls'</span>, <span style="color: #CC9393;">'Blancs'</span>, <span style="color: #CC9393;">'Abstentions'</span>]].copy()
<span style="color: #DFAF8F;">df_1</span>[<span style="color: #CC9393;">"Non exprim&#233;s"</span>] =  df_1[<span style="color: #CC9393;">'Nuls'</span>] + df_1[<span style="color: #CC9393;">'Blancs'</span>] + df_1[<span style="color: #CC9393;">'Abstentions'</span>]
<span style="color: #DFAF8F;">df_1</span> = df_1[[<span style="color: #CC9393;">"Non exprim&#233;s"</span>]].copy()

<span style="color: #DFAF8F;">T1</span>[<span style="color: #CC9393;">'Code de la circonscription'</span>] = T1[<span style="color: #CC9393;">'Code de la circonscription'</span>].<span style="color: #DCDCCC; font-weight: bold;">apply</span>(<span style="color: #DCDCCC; font-weight: bold;">str</span>)
<span style="color: #DFAF8F;">circonscriptions</span> = T1[<span style="color: #CC9393;">'Code du d&#233;partement'</span>] + T1[<span style="color: #CC9393;">'Code de la circonscription'</span>]

df_1.head()
</pre>
</div>

<p>
Et on réccupère maintenant les votes par candidat:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">col_start</span> = 21
<span style="color: #DFAF8F;">col_par_cdt</span> = 7
<span style="color: #DFAF8F;">candidats</span> = T1.iloc[0][col_start::col_par_cdt]

<span style="color: #F0DFAF; font-weight: bold;">for</span> i_candidat, candidat <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(candidats):
    <span style="color: #DFAF8F;">i_col</span> = col_start + i_candidat*col_par_cdt + 2
    <span style="color: #DFAF8F;">df_1</span>[candidat] = T1.iloc[:, i_col].values
</pre>
</div>

<p>
On peut maintenant regarder la distribution des votes au premier tour:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #F0DFAF; font-weight: bold;">as</span> plt

<span style="color: #DFAF8F;">results</span> = df_1.<span style="color: #DCDCCC; font-weight: bold;">sum</span>()/df_1.<span style="color: #DCDCCC; font-weight: bold;">sum</span>().<span style="color: #DCDCCC; font-weight: bold;">sum</span>()

<span style="color: #DFAF8F;">fig</span>, <span style="color: #DFAF8F;">ax</span> = plt.subplots(figsize=(13, 5))
<span style="color: #DFAF8F;">ax</span> = results.plot.bar(ax=ax)

ax.set_yticks([])

<span style="color: #DFAF8F;">spines_to_remove</span> = [<span style="color: #CC9393;">"top"</span>, <span style="color: #CC9393;">"left"</span>, <span style="color: #CC9393;">"right"</span>]
<span style="color: #F0DFAF; font-weight: bold;">for</span> spine <span style="color: #F0DFAF; font-weight: bold;">in</span> spines_to_remove:
    ax.spines[spine].set_visible(<span style="color: #BFEBBF;">False</span>)


<span style="color: #F0DFAF; font-weight: bold;">for</span> i, val <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(<span style="color: #DCDCCC; font-weight: bold;">list</span>(results.values)):
    plt.text(i, val + 0.01, f<span style="color: #CC9393;">"{val*100:.01f}%"</span>, ha=<span style="color: #CC9393;">"center"</span>)

plt.title(<span style="color: #CC9393;">"R&#233;sultats du premier tour"</span>)
plt.savefig(filename, bbox_inches=<span style="color: #CC9393;">"tight"</span>)
filename
</pre>
</div>

<p>
#+attr<sub>html</sub> :width 100%
</p>

<div id="orgbaf0bd7" class="figure">
<p><img src="figs/presidentielles-report-voix/resultats-premier-tour.png" alt="resultats-premier-tour.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org43e0530" class="outline-3">
<h3 id="org43e0530">Deuxième tour</h3>
<div class="outline-text-3" id="text-org43e0530">
<p>
Le processus de récupération des données est identique pour le second tour :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fname</span> = <span style="color: #CC9393;">'/tmp/T2.xlsx'</span>

<span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> os.path.isfile(fname):
    <span style="color: #DFAF8F;">url</span> = <span style="color: #CC9393;">"https://www.data.gouv.fr/fr/datasets/r/5eacdbc7-b1a2-440c-8eef-09c8bfb87609"</span>
    <span style="color: #F0DFAF; font-weight: bold;">import</span> urllib.request
    urllib.request.urlretrieve(url, fname)

<span style="color: #DFAF8F;">T2</span> = pd.read_excel(fname)

<span style="color: #DFAF8F;">df_2</span> = T2[[<span style="color: #CC9393;">'Nuls'</span>, <span style="color: #CC9393;">'Blancs'</span>, <span style="color: #CC9393;">'Abstentions'</span>]].copy()
<span style="color: #DFAF8F;">df_2</span>[<span style="color: #CC9393;">"Non exprim&#233;s"</span>] =  df_2[<span style="color: #CC9393;">'Nuls'</span>] + df_2[<span style="color: #CC9393;">'Blancs'</span>] + df_2[<span style="color: #CC9393;">'Abstentions'</span>]
<span style="color: #DFAF8F;">df_2</span> = df_2[[<span style="color: #CC9393;">"Non exprim&#233;s"</span>]].copy()

<span style="color: #DFAF8F;">col_start</span> = 21
<span style="color: #DFAF8F;">col_par_cdt</span> = 7
<span style="color: #DFAF8F;">candidats</span> = T2.iloc[0][col_start::col_par_cdt]

<span style="color: #F0DFAF; font-weight: bold;">for</span> i_candidat, candidat <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(candidats):
    <span style="color: #DFAF8F;">i_col</span> = col_start + i_candidat*col_par_cdt + 2
    <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'# colonne'</span>, i_col, <span style="color: #CC9393;">' r&#233;sultats='</span>, T2.iloc[:, i_col].values)
    <span style="color: #DFAF8F;">df_2</span>[candidat] = T2.iloc[:, i_col].values
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #F0DFAF; font-weight: bold;">as</span> plt

<span style="color: #DFAF8F;">results</span> = df_2.<span style="color: #DCDCCC; font-weight: bold;">sum</span>()/df_2.<span style="color: #DCDCCC; font-weight: bold;">sum</span>().<span style="color: #DCDCCC; font-weight: bold;">sum</span>()

<span style="color: #DFAF8F;">fig</span>, <span style="color: #DFAF8F;">ax</span> = plt.subplots(figsize=(13, 5))
<span style="color: #DFAF8F;">ax</span> = results.plot.bar(ax=ax)

ax.set_yticks([])

<span style="color: #DFAF8F;">spines_to_remove</span> = [<span style="color: #CC9393;">"top"</span>, <span style="color: #CC9393;">"left"</span>, <span style="color: #CC9393;">"right"</span>]
<span style="color: #F0DFAF; font-weight: bold;">for</span> spine <span style="color: #F0DFAF; font-weight: bold;">in</span> spines_to_remove:
    ax.spines[spine].set_visible(<span style="color: #BFEBBF;">False</span>)


<span style="color: #F0DFAF; font-weight: bold;">for</span> i, val <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">enumerate</span>(<span style="color: #DCDCCC; font-weight: bold;">list</span>(results.values)):
    plt.text(i, val + 0.01, f<span style="color: #CC9393;">"{val*100:.01f}%"</span>, ha=<span style="color: #CC9393;">"center"</span>)

plt.title(<span style="color: #CC9393;">"R&#233;sultats du second tour"</span>)
plt.savefig(filename, bbox_inches=<span style="color: #CC9393;">"tight"</span>)
filename
</pre>
</div>

<p>
#+attr<sub>html</sub> :width 100%
</p>

<div id="orgd618cda" class="figure">
<p><img src="figs/presidentielles-report-voix/resultats-second-tour.png" alt="resultats-second-tour.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org8a55a4b" class="outline-3">
<h3 id="org8a55a4b">Second order</h3>
<div class="outline-text-3" id="text-org8a55a4b">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> seaborn <span style="color: #F0DFAF; font-weight: bold;">as</span> sns

<span style="color: #DFAF8F;">CDT_1</span> = <span style="color: #CC9393;">"ARTHAUD"</span>
<span style="color: #DFAF8F;">CDT_2</span> = <span style="color: #CC9393;">"LE PEN"</span>

<span style="color: #DFAF8F;">df_12</span> = pd.DataFrame()
<span style="color: #DFAF8F;">df_12</span>[CDT_1] = df_1[CDT_1].copy()
<span style="color: #DFAF8F;">df_12</span>[CDT_2] = df_2[CDT_2].copy()

<span style="color: #DFAF8F;">df_12</span>[CDT_1] = df_12[CDT_1]/df_1.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
<span style="color: #DFAF8F;">df_12</span>[CDT_2] = df_12[CDT_2]/df_2.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)

<span style="color: #DFAF8F;">fig</span> = plt.figure()
sns.jointplot(x=df_12[CDT_1], y=df_12[CDT_2], xlim=(0, 0.02), ylim=(0, 1), kind=<span style="color: #CC9393;">'hist'</span>, height=8);
plt.savefig(filename)
filename
</pre>
</div>


<div id="org063f4a5" class="figure">
<p><img src="file:///tmp/babel-DTyOHT/figures6n2pL.png" alt="figures6n2pL.png" />
</p>
</div>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> seaborn <span style="color: #F0DFAF; font-weight: bold;">as</span> sns

<span style="color: #DFAF8F;">CDT_1</span> = <span style="color: #CC9393;">"ARTHAUD"</span>
<span style="color: #DFAF8F;">CDT_2</span> = <span style="color: #CC9393;">"Non exprim&#233;s"</span>

<span style="color: #DFAF8F;">df_12</span> = pd.DataFrame()
<span style="color: #DFAF8F;">df_12</span>[CDT_1] = df_1[CDT_1].copy()
<span style="color: #DFAF8F;">df_12</span>[CDT_2] = df_2[CDT_2].copy()

<span style="color: #DFAF8F;">df_12</span>[CDT_1] = df_12[CDT_1]/df_1.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
<span style="color: #DFAF8F;">df_12</span>[CDT_2] = df_12[CDT_2]/df_2.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)

<span style="color: #DFAF8F;">fig</span> = plt.figure()
sns.jointplot(x=df_12[CDT_1], y=df_12[CDT_2], xlim=(0,0.02), ylim=(0, 1), kind=<span style="color: #CC9393;">'hist'</span>, height=8);
plt.savefig(filename)
filename
</pre>
</div>


<div id="orga920e5d" class="figure">
<p><img src="file:///tmp/babel-DTyOHT/figurePLSP8R.png" alt="figurePLSP8R.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> seaborn <span style="color: #F0DFAF; font-weight: bold;">as</span> sns

<span style="color: #DFAF8F;">CDT_1</span> = <span style="color: #CC9393;">"Non exprim&#233;s"</span>
<span style="color: #DFAF8F;">CDT_2</span> = <span style="color: #CC9393;">"MACRON"</span>

<span style="color: #DFAF8F;">df_12</span> = pd.DataFrame()
<span style="color: #DFAF8F;">df_12</span>[CDT_1] = df_1[CDT_1].copy()
<span style="color: #DFAF8F;">df_12</span>[CDT_2] = df_2[CDT_2].copy()

<span style="color: #DFAF8F;">df_12</span>[CDT_1] = df_12[CDT_1]/df_1.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
<span style="color: #DFAF8F;">df_12</span>[CDT_2] = df_12[CDT_2]/df_2.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)

<span style="color: #DFAF8F;">fig</span> = plt.figure()
sns.jointplot(x=df_12[CDT_1], y=df_12[CDT_2], xlim=(0, 1), ylim=(0, 1), kind=<span style="color: #CC9393;">'hist'</span>, height=8);
plt.savefig(filename)
filename
</pre>
</div>


<div id="org182edea" class="figure">
<p><img src="file:///tmp/babel-DTyOHT/figurei4jzIx.png" alt="figurei4jzIx.png" />
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org4250cac" class="outline-2">
<h2 id="org4250cac">Simple modèle écologique</h2>
<div class="outline-text-2" id="text-org4250cac">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">second</span> = df_2[1:].values[:577, :]
<span style="color: #DFAF8F;">premier</span> = df_1[1:].values[:577:]
<span style="color: #DFAF8F;">n_premier</span> = premier.shape[1]
<span style="color: #DFAF8F;">n_second</span> = second.shape[1]
<span style="color: #DFAF8F;">n_circos</span> = premier.shape[0]
</pre>
</div>

<p>
The model we implement is taken from <a target='_blank' rel='noopener noreferrer' class='external' href="https://gking.harvard.edu/files/em.pdf">this paper.</a> We will be using <code>aesara</code> for modelling and <code>blackjax</code> for sampling.
</p>
</div>

<div id="outline-container-org2e1b41d" class="outline-3">
<h3 id="org2e1b41d"><span class="todo TODO">TODO</span> Full mixing</h3>
<div class="outline-text-3" id="text-org2e1b41d">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> aesara.tensor <span style="color: #F0DFAF; font-weight: bold;">as</span> at
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.tensor.random <span style="color: #F0DFAF; font-weight: bold;">import</span> RandomStream

<span style="color: #DFAF8F;">srng</span> = RandomStream(0)

<span style="color: #DFAF8F;">p1_at</span> = at.as_tensor(premier / premier.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1).reshape((premier.shape[0], 1)))
<span style="color: #DFAF8F;">beta_rv</span> = srng.dirichlet(at.ones((n_premier, n_second)))
<span style="color: #DFAF8F;">p2_at</span> = at.dot(p1_at, beta_rv)
<span style="color: #DFAF8F;">p2_at_norm</span> = p2_at / p2_at.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1).reshape((p2_at.shape[0], 1))
<span style="color: #DFAF8F;">R2_rv</span> = srng.multinomial(at.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(second, axis=1), p2_at)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.link.jax.dispatch <span style="color: #F0DFAF; font-weight: bold;">import</span> jax_funcify
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.graph.fg <span style="color: #F0DFAF; font-weight: bold;">import</span> FunctionGraph
<span style="color: #F0DFAF; font-weight: bold;">from</span> aeppl.opt <span style="color: #F0DFAF; font-weight: bold;">import</span> logprob_rewrites_db
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.<span style="color: #DCDCCC; font-weight: bold;">compile</span> <span style="color: #F0DFAF; font-weight: bold;">import</span> mode
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.raise_op <span style="color: #F0DFAF; font-weight: bold;">import</span> CheckAndRaise

<span style="color: #7CB8BB;">@jax_funcify.register</span>(CheckAndRaise)
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">jax_funcify_Assert</span>(op, **kwargs):
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Jax does not allow assert whose values aren't known during JIT compilation</span>
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">within it's JIT-ed code. Hence we need to make a simple pass through</span>
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">version of the Assert Op.</span>
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">https://github.com/google/jax/issues/2273#issuecomment-589098722</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">assert_fn</span>(value, *inps):
        <span style="color: #F0DFAF; font-weight: bold;">return</span> value

    <span style="color: #F0DFAF; font-weight: bold;">return</span> assert_fn

<span style="color: #DFAF8F;">fgraph</span> = FunctionGraph(inputs=(beta_vv, R2_vv), outputs=(logprob,))
mode.JAX.optimizer.optimize(fgraph)
<span style="color: #DFAF8F;">jax_fn</span> = jax_funcify(fgraph)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">M</span> = SimplexTransform().forward(beta_rv).<span style="color: #DCDCCC; font-weight: bold;">eval</span>()
<span style="color: #F0DFAF; font-weight: bold;">print</span>(jax_fn(M, second)[0])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">logpdf</span>(beta):
    <span style="color: #F0DFAF; font-weight: bold;">return</span> jax_fn(beta, second)[0]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> jax
<span style="color: #F0DFAF; font-weight: bold;">import</span> blackjax


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">inference_loop</span>(rng_key, kernel, initial_state, num_samples):
    <span style="color: #9FC59F;">"""Sequantially draws samples given the kernel of choice."""</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">one_step</span>(state, rng_key):
        <span style="color: #DFAF8F;">state</span>, <span style="color: #DFAF8F;">_</span> = kernel(rng_key, state)
        <span style="color: #F0DFAF; font-weight: bold;">return</span> state, state

    <span style="color: #DFAF8F;">keys</span> = jax.random.split(rng_key, num_samples)
    <span style="color: #DFAF8F;">_</span>, <span style="color: #DFAF8F;">states</span> = jax.lax.scan(one_step, initial_state, keys)

    <span style="color: #F0DFAF; font-weight: bold;">return</span> states


<span style="color: #DFAF8F;">rng</span> = jax.random.PRNGKey(0)
<span style="color: #DFAF8F;">adapt</span> = blackjax.window_adaptation(blackjax.nuts, logpdf, 3000, initial_step_size=1., target_acceptance_rate=0.8)
<span style="color: #DFAF8F;">state</span>, <span style="color: #DFAF8F;">kernel</span>, <span style="color: #DFAF8F;">_</span> = adapt.run(rng, M)
<span style="color: #DFAF8F;">samples</span> = inference_loop(rng, kernel, state, 1000)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">trans_at</span> = at.matrix()
<span style="color: #DFAF8F;">untrans_at</span> = SimplexTransform().backward(trans_at)

<span style="color: #DFAF8F;">fgraph</span> = FunctionGraph(inputs=(trans_at,), outputs=(untrans_at,))
mode.JAX.optimizer.optimize(fgraph)
<span style="color: #DFAF8F;">untransform_fn</span> = jax_funcify(fgraph)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">a</span> = jax.vmap(untransform_fn, in_axes=(0))(samples.position)[0]
jnp.mean(a, axis=0)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">jnp.std(a, axis=0)
</pre>
</div>

<p>
On vérifie que le modèle, aussi surprenant que cela soit, est k
</p>

<div class="org-src-container">
<pre class="src src-python">a[:, 1, 2][:100]
</pre>
</div>
</div>
</div>

<div id="outline-container-org2a8055b" class="outline-3">
<h3 id="org2a8055b"><span class="todo TODO">TODO</span> Hyperprior on dirichlet</h3>
<div class="outline-text-3" id="text-org2a8055b">
<p>
Per the paper on ecological inference we add an exponential hyperprior on the dirichlet distribution.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">second</span> = df_2[1:].values[:100,:]
<span style="color: #DFAF8F;">premier</span> = df_1[1:].values[:100,:]
<span style="color: #DFAF8F;">n_premier</span> = premier.shape[1]
<span style="color: #DFAF8F;">n_second</span> = second.shape[1]
<span style="color: #DFAF8F;">n_circos</span> = premier.shape[0]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> aesara.tensor <span style="color: #F0DFAF; font-weight: bold;">as</span> at
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.tensor.random <span style="color: #F0DFAF; font-weight: bold;">import</span> RandomStream

<span style="color: #DFAF8F;">srng</span> = RandomStream(0)

<span style="color: #DFAF8F;">p1_at</span> = at.as_tensor(premier / premier.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1).reshape((premier.shape[0], 1)))
<span style="color: #DFAF8F;">delta_rv</span> = srng.exponential(at.ones((n_premier, n_second)) * 10.)
<span style="color: #DFAF8F;">beta_rv</span> = srng.dirichlet(delta_rv)
<span style="color: #DFAF8F;">p2_at</span> = at.dot(p1_at, beta_rv)
<span style="color: #DFAF8F;">p2_at_norm</span> = p2_at / p2_at.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1).reshape((p2_at.shape[0], 1))
<span style="color: #DFAF8F;">R2_rv</span> = srng.multinomial(at.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(second, axis=1), p2_at)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> aeppl.transforms <span style="color: #F0DFAF; font-weight: bold;">import</span> TransformValuesOpt, LogTransform, SimplexTransform


<span style="color: #DFAF8F;">R2_vv</span> = R2_rv.clone()
<span style="color: #DFAF8F;">beta_vv</span> = beta_rv.clone()
<span style="color: #DFAF8F;">delta_vv</span> = delta_rv.clone()

<span style="color: #DFAF8F;">transforms_op</span> = TransformValuesOpt(
     {beta_vv: SimplexTransform(), delta_vv: LogTransform()}
)
<span style="color: #DFAF8F;">logprob</span> = joint_logprob(
    {R2_rv: R2_vv, beta_rv: beta_vv, delta_rv: delta_vv},
    extra_rewrites=transforms_op
)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Compile the logprob function</span>
<span style="color: #DFAF8F;">logprob_fn</span> = aesara.function((beta_vv, delta_vv, R2_vv), logprob)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">beta</span> = SimplexTransform().forward(beta_rv).<span style="color: #DCDCCC; font-weight: bold;">eval</span>()
<span style="color: #DFAF8F;">delta</span> = LogTransform().forward(delta_rv).<span style="color: #DCDCCC; font-weight: bold;">eval</span>()
<span style="color: #F0DFAF; font-weight: bold;">print</span>(logprob_fn(beta, delta, second))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.link.jax.dispatch <span style="color: #F0DFAF; font-weight: bold;">import</span> jax_funcify
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.graph.fg <span style="color: #F0DFAF; font-weight: bold;">import</span> FunctionGraph
<span style="color: #F0DFAF; font-weight: bold;">from</span> aeppl.opt <span style="color: #F0DFAF; font-weight: bold;">import</span> logprob_rewrites_db
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.<span style="color: #DCDCCC; font-weight: bold;">compile</span> <span style="color: #F0DFAF; font-weight: bold;">import</span> mode
<span style="color: #F0DFAF; font-weight: bold;">from</span> aesara.raise_op <span style="color: #F0DFAF; font-weight: bold;">import</span> CheckAndRaise

<span style="color: #7CB8BB;">@jax_funcify.register</span>(CheckAndRaise)
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">jax_funcify_Assert</span>(op, **kwargs):
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Jax does not allow assert whose values aren't known during JIT compilation</span>
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">within it's JIT-ed code. Hence we need to make a simple pass through</span>
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">version of the Assert Op.</span>
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">https://github.com/google/jax/issues/2273#issuecomment-589098722</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">assert_fn</span>(value, *inps):
        <span style="color: #F0DFAF; font-weight: bold;">return</span> value

    <span style="color: #F0DFAF; font-weight: bold;">return</span> assert_fn

<span style="color: #DFAF8F;">fgraph</span> = FunctionGraph(inputs=(beta_vv, delta_vv, R2_vv), outputs=(logprob,))
mode.JAX.optimizer.optimize(fgraph)
<span style="color: #DFAF8F;">jax_fn</span> = jax_funcify(fgraph)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">M</span> = SimplexTransform().forward(beta_rv).<span style="color: #DCDCCC; font-weight: bold;">eval</span>()
<span style="color: #DFAF8F;">d</span> = LogTransform().forward(delta_rv).<span style="color: #DCDCCC; font-weight: bold;">eval</span>()
<span style="color: #F0DFAF; font-weight: bold;">print</span>(jax_fn(M, d, second)[0])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">logpdf</span>(x):
    <span style="color: #DFAF8F;">beta</span>, <span style="color: #DFAF8F;">delta</span> = x
    <span style="color: #F0DFAF; font-weight: bold;">return</span> jax_fn(beta, delta, second)[0]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> jax
<span style="color: #F0DFAF; font-weight: bold;">import</span> blackjax


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">inference_loop</span>(rng_key, kernel, initial_state, num_samples):
    <span style="color: #9FC59F;">"""Sequantially draws samples given the kernel of choice."""</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">one_step</span>(state, rng_key):
        <span style="color: #DFAF8F;">state</span>, <span style="color: #DFAF8F;">_</span> = kernel(rng_key, state)
        <span style="color: #F0DFAF; font-weight: bold;">return</span> state, state

    <span style="color: #DFAF8F;">keys</span> = jax.random.split(rng_key, num_samples)
    <span style="color: #DFAF8F;">_</span>, <span style="color: #DFAF8F;">states</span> = jax.lax.scan(one_step, initial_state, keys)

    <span style="color: #F0DFAF; font-weight: bold;">return</span> states


<span style="color: #DFAF8F;">rng</span> = jax.random.PRNGKey(0)
<span style="color: #DFAF8F;">adapt</span> = blackjax.window_adaptation(blackjax.nuts, logpdf, 3000, initial_step_size=1., target_acceptance_rate=0.8)
<span style="color: #DFAF8F;">state</span>, <span style="color: #DFAF8F;">kernel</span>, <span style="color: #DFAF8F;">_</span> = adapt.run(rng, (M, d))
<span style="color: #DFAF8F;">samples</span> = inference_loop(rng, kernel, state, 1000)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">trans_at</span> = at.matrix()
<span style="color: #DFAF8F;">untrans_at</span> = LogTransform().backward(trans_at)

<span style="color: #DFAF8F;">fgraph</span> = FunctionGraph(inputs=(trans_at,), outputs=(untrans_at,))
mode.JAX.optimizer.optimize(fgraph)
<span style="color: #DFAF8F;">untransform_fn</span> = jax_funcify(fgraph)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">a</span> = jax.vmap(untransform_fn, in_axes=(0))(samples.position[1])[0]
jnp.mean(a, axis=0)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">jnp.std(a, axis=0)
</pre>
</div>

<p>
Les résultats sont de toute évidence faux: il suffit de comparer les graphes avec les statistiques de second ordre plus haut et les valeurs que l'on obtient pour les priors des distributions des lignes de la matrice de transition. Pour comprendre ce qui se passe il va falloir retourner au tableau, et notamment regarder les <i>prior predictive distributions</i> pour les matrices de transition et voir si elles permettent de retrouver les courbes X au premier tour vs Y au second tour. Trois hypothèses:
</p>

<ul class="org-ul">
<li>La paramétrisation du modèle est mauvaise;</li>
<li>L'impact des variations de la logprob correspondants aux petit candidats est tellement faible que le modèle est surtout déterminé par la valeur a priori. On peut alors soit prendre un sondage pour les valeurs a priori, soit les "fabriquer".</li>
<li>Le modèle hiérarchique est nécessaire. Un moyen de voir si cela va changer quelque chose est de fitter ce modèle sur une seule circonscription.</li>
</ul>
</div>
</div>
<div id="outline-container-org170fa1b" class="outline-3">
<h3 id="org170fa1b"><span class="todo TODO">TODO</span> Explain why we get weird results with full mixing</h3>
</div>
<div id="outline-container-org51bc2c8" class="outline-3">
<h3 id="org51bc2c8"><span class="todo TODO">TODO</span> Hierarchical model</h3>
<div class="outline-text-3" id="text-org51bc2c8">
<p>
The hierarchical model should allow us to give more reasonable national estimates. It is not purely descriptive as this gives us access to a quantity we did not have access to before: the transition matrices.
</p>
</div>
</div>
<div id="outline-container-orgc476dad" class="outline-3">
<h3 id="orgc476dad"><span class="todo TODO">TODO</span> Extract information from the model</h3>
</div>
</div>
</div>
</body>
</html>