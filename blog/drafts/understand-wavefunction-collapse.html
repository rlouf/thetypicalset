<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-01 Thu 10:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MiniKanren and WaveFunction Collapse I - The Even Simpler Tiled Model</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">MiniKanren and WaveFunction Collapse I - The Even Simpler Tiled Model</h1>
<p>
Image generation does lend itself quite naturally to <i>declarative programming</i>. In the end we are not so interested in <i>how</i> the image was generated as <i>what</i> it looks like. What it looks like is determined by how neighbouring pixels <i>relate</i> to each other.
</p>

<p>
Methods like Wavefunction collapse will start from example tiles, which describe <i>how</i> we want the picture to look like, and try to extrapolate them to a larger picture. Wavefunction collapse is about finding the pixel arrangement that satistifies some local constraints as defined by the original tiles. But quite in a similar fashion to <a href="file:///home/runner/projects/thetypicalset/org/blog/solve-sudokus-kanren.html">Peter Norvig's solution to the sudoku</a>, much of the thought is given to the search strategy.
</p>


<p>
<a target='_blank' rel='noopener noreferrer' class='external' href="https://robertheaton.com/2018/12/17/wavefunction-collapse-algorithm/">This link</a> has a simple explanation of Wavefunction Collapse in terms of constraint propagation.
</p>

<p>
The first wavefunction is a superposition of every possible results (akin to logic variables). Collapsing is taking one possible solution at random from all the possiblities. This choice has consequences that ripple out throught the rest of the solution space -&gt; remove the solutions that become impossible conditional to the first choice you made. Repeat until everything is collapsed or until you've met a <i>contradiction</i> (which makes collapse impossible). Start again if it fails.
</p>

<p>
Here we try to arrange pixels in an input image.
</p>

<div id="outline-container-orgf17cf74" class="outline-2">
<h2 id="orgf17cf74">Even simpler tiled model</h2>
</div>
<div id="outline-container-orga0aee7f" class="outline-2">
<h2 id="orga0aee7f"><span class="todo TODO">TODO</span> Do on 1D line (sea-cost-land-cost-sea-sea-cost-land-land-coast)</h2>
<div class="outline-text-2" id="text-orga0aee7f">
<p>
Here I reproduce the example of <a target='_blank' rel='noopener noreferrer' class='external' href="https://robertheaton.com/2018/12/17/wavefunction-collapse-algorithm/">this article</a>.
</p>

<p>
In the <i>Even Simpler Tiled Model</i> each tile is a single pixel of a single color. The rules specify how tiles can be placed one to another, and each rule is a tuple which designates two tiles, and how they can be adjacent to one another.
</p>

<p>
For instance, <code>("sea", "coast", "left")</code> specifies that a <code>sea</code> tile can be placed on the <code>left</code> of a <code>coast</code> tile.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #24292e;">tiles</span> = ((<span style="color: #032f62;">"s"</span>,<span style="color: #032f62;">"s"</span>), (<span style="color: #032f62;">"s"</span>,<span style="color: #032f62;">"c"</span>), (<span style="color: #032f62;">"c"</span>, <span style="color: #032f62;">"c"</span>), (<span style="color: #032f62;">"c"</span>,<span style="color: #032f62;">"s"</span>), (<span style="color: #032f62;">"c"</span>,<span style="color: #032f62;">"l"</span>), (<span style="color: #032f62;">"l,c"</span>), (<span style="color: #032f62;">"l,l"</span>))
</pre>
</div>

<p>
We can have the program parse an input image and learn adjacencies from this. Apparently it also needs to count the number of times each tile appears.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #24292e;">example_img</span> = [[<span style="color: #032f62;">"s"</span>, <span style="color: #032f62;">"s"</span>, <span style="color: #032f62;">"s"</span>], [<span style="color: #032f62;">"c"</span>, <span style="color: #032f62;">"c"</span>, <span style="color: #032f62;">"s"</span>], [<span style="color: #032f62;">"l"</span>, <span style="color: #032f62;">"l"</span>, <span style="color: #032f62;">"c"</span>]]
</pre>
</div>

<p>
There is a notion of randomness here that we cannot really account for with (or can we?). Let us extract from the grid the relations between pixels that we'd like to constraint:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">def</span> <span style="color: #6f42c1;">horizontal_pairs</span>(grid):
    <span style="color: #24292e;">length</span> = <span style="color: #24292e;">height</span> = <span style="color: #d73a49;">len</span>(grid)
    <span style="color: #d73a49;">return</span> [(grid[i][j], grid[i][j+1]) <span style="color: #d73a49;">for</span> i <span style="color: #d73a49;">in</span> <span style="color: #d73a49;">range</span>(height) <span style="color: #d73a49;">for</span> j <span style="color: #d73a49;">in</span> <span style="color: #d73a49;">range</span>(length-1)]

<span style="color: #d73a49;">def</span> <span style="color: #6f42c1;">vertical_pairs</span>(grid):
    <span style="color: #24292e;">length</span> = <span style="color: #24292e;">height</span> = <span style="color: #d73a49;">len</span>(grid)
    <span style="color: #d73a49;">return</span> [(grid[i][j], grid[i+1][j]) <span style="color: #d73a49;">for</span> i <span style="color: #d73a49;">in</span> <span style="color: #d73a49;">range</span>(height-1) <span style="color: #d73a49;">for</span> j <span style="color: #d73a49;">in</span> <span style="color: #d73a49;">range</span>(length)]
</pre>
</div>


<p>
Let's say that the observed relations between grid elements are in the tuple <code>adjacency["left"]</code> then
the correponding goal is:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> kanren <span style="color: #d73a49;">import</span> lall, lany, eq, <span style="color: #d73a49;">vars</span>, run
<span style="color: #d73a49;">from</span> kanren.goals <span style="color: #d73a49;">import</span> permuteo

<span style="color: #24292e;">tiles</span> = ((<span style="color: #032f62;">"s"</span>,<span style="color: #032f62;">"s"</span>), (<span style="color: #032f62;">"s"</span>,<span style="color: #032f62;">"c"</span>), (<span style="color: #032f62;">"c"</span>, <span style="color: #032f62;">"c"</span>), (<span style="color: #032f62;">"c"</span>,<span style="color: #032f62;">"s"</span>), (<span style="color: #032f62;">"c"</span>,<span style="color: #032f62;">"l"</span>), (<span style="color: #032f62;">"l,c"</span>), (<span style="color: #032f62;">"l,l"</span>))
<span style="color: #24292e;">ratios</span> = {<span style="color: #032f62;">"c"</span>: 3/9, <span style="color: #032f62;">"s"</span>: 4/9, <span style="color: #032f62;">"l"</span>: 2/9}
<span style="color: #24292e;">tiles</span> = [(<span style="color: #032f62;">"s"</span>, <span style="color: #032f62;">"s"</span>)]

<span style="color: #d73a49;">def</span> <span style="color: #6f42c1;">get_pairs</span>(line):
    <span style="color: #d73a49;">return</span> [(a, b) <span style="color: #d73a49;">for</span> a, b <span style="color: #d73a49;">in</span> <span style="color: #d73a49;">zip</span>(line[:-1], line[1:])]


<span style="color: #d73a49;">def</span> <span style="color: #6f42c1;">generate</span>(grid, colors):
    <span style="color: #24292e;">pairs</span> = get_pairs(grid)
    <span style="color: #d73a49;">return</span> lall(
        <span style="color: #6a737d;">#</span><span style="color: #6a737d;">permuteo(grid, colors),</span>
        *[lany(*[eq(obs, pair) <span style="color: #d73a49;">for</span> obs <span style="color: #d73a49;">in</span> tiles]) <span style="color: #d73a49;">for</span> pair <span style="color: #d73a49;">in</span> pairs]
    )

<span style="color: #24292e;">N</span> = 1000
<span style="color: #24292e;">grid</span> = <span style="color: #d73a49;">vars</span>(N)
<span style="color: #24292e;">colors</span> = [<span style="color: #032f62;">"c"</span>] * <span style="color: #d73a49;">int</span>(ratios[<span style="color: #032f62;">"c"</span>] * N) + [<span style="color: #032f62;">"l"</span>] * <span style="color: #d73a49;">int</span>(ratios[<span style="color: #032f62;">"l"</span>] * N) + [<span style="color: #032f62;">"s"</span>] * (N - <span style="color: #d73a49;">int</span>(ratios[<span style="color: #032f62;">"c"</span>] * N) - <span style="color: #d73a49;">int</span>(ratios[<span style="color: #032f62;">"l"</span>] * N))

<span style="color: #24292e;">res</span> = run(1, grid, generate(grid, colors))
<span style="color: #d73a49;">print</span>(res)
</pre>
</div>

<p>
Ok so this is not great.
</p>
</div>


<div id="outline-container-org9345148" class="outline-3">
<h3 id="org9345148"><span class="todo TODO">TODO</span> Plot the results each time</h3>
</div>
</div>

<div id="outline-container-orgeda415f" class="outline-2">
<h2 id="orgeda415f">TODO</h2>
</div>

<div id="outline-container-org1eef85a" class="outline-2">
<h2 id="org1eef85a"><span class="todo TODO">TODO</span> Show the grid as it is being built (i.e. the miniKanren state being passed)</h2>
</div>
<div id="outline-container-orgf22cad6" class="outline-2">
<h2 id="orgf22cad6"><span class="todo TODO">TODO</span> Show the stream of possible grids in a stream.</h2>
</div>
<div id="outline-container-org8ada3e9" class="outline-2">
<h2 id="org8ada3e9"><span class="todo TODO">TODO</span> What is the influence of the original adjacency matrix?</h2>
<div class="outline-text-2" id="text-org8ada3e9">
<p>
In particular I would like to understand if more land on the original image will indeed lead to
more land on the final images. Maybe show the result as a function of % of land at the beginning. This is a central-ish feature of the Wavefunction Collapse.
</p>
</div>
</div>
<div id="outline-container-org3db27bc" class="outline-2">
<h2 id="org3db27bc"><span class="todo TODO">TODO</span> Realtion between kanren and the entropy heuristic?</h2>
</div>

<div id="outline-container-org8655ef5" class="outline-2">
<h2 id="org8655ef5">Simple tiled model</h2>
<div class="outline-text-2" id="text-org8655ef5">
<p>
Small number of small pre-defined tiles that define "rules" such as land, sea, coast, mountains. We choose the tile with the lowest entropy to collapse the wavefunction.
</p>

<p>
Initially the state is completely unobserved:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> kanren <span style="color: #d73a49;">import</span> <span style="color: #d73a49;">vars</span>

<span style="color: #24292e;">width</span> = 10
<span style="color: #24292e;">height</span> = 10

<span style="color: #24292e;">grid</span> = <span style="color: #d73a49;">vars</span>(width * height)
</pre>
</div>

<p>
Well actually, each pixel value is constrained to be one of the colors of the input bitmap
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> kanren <span style="color: #d73a49;">import</span> lall, membero

<span style="color: #24292e;">BITMAP</span> = (1, 2, 3, 4)
<span style="color: #24292e;">goal</span> = lall(*<span style="color: #d73a49;">tuple</span>(membero(pixel, BITMAP) <span style="color: #d73a49;">for</span> pixel <span style="color: #d73a49;">in</span> grid))
</pre>
</div>

<p>
From what I understand the resulting grid can only be a combination of the input tiles. Let's consider a simple grid with 1x2 tiles:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #24292e;">input_tile</span> = [(1, 2), (1, 1), (2, 3)]
<span style="color: #24292e;">target_tiles</span> = get_tiles(grid)  <span style="color: #6a737d;"># </span><span style="color: #6a737d;">extract tiles from the target grid</span>
<span style="color: #24292e;">goal</span> = lall(*<span style="color: #d73a49;">tuple</span>(lany(*<span style="color: #d73a49;">tuple</span>(membero(tile, model) <span style="color: #d73a49;">for</span> model <span style="color: #d73a49;">in</span> input_tiles)) <span style="color: #d73a49;">for</span> tile <span style="color: #d73a49;">in</span> target_tiles))
</pre>
</div>

<p>
So really the complicated thing is extracting the tiles in the grid and how you do that. Manage symmetries is just applying transforms to the input.
</p>
</div>
</div>
</div>
</body>
</html>