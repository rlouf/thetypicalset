<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-21 Wed 19:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>miniKanren in Python</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">miniKanren in Python</h1>
<p>
In this article I will give an overview of the <code>kanren</code> library which is an implementation of miniKanren in python. We will go over the library's design. We assume that we are able to define <code>unify</code> and <code>reify</code> functions.
</p>

<div id="outline-container-orgab5ebe2" class="outline-2">
<h2 id="orgab5ebe2">Goals</h2>
<div class="outline-text-2" id="text-orgab5ebe2">
<p>
In <code>kanren</code> we wish to express relations between variables with <i>goals</i>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">relation</span>(s, t):
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">relation_goal</span>(s):
        <span style="color: #F0DFAF; font-weight: bold;">pass</span>
    <span style="color: #F0DFAF; font-weight: bold;">pass</span>
</pre>
</div>

<p>
The simplest example of this is the <code>eq</code> relation, which specifies that two variables must unify:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> unification <span style="color: #F0DFAF; font-weight: bold;">import</span> unify, reify, var

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">eq</span>(u, v):
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">u and v are two variables. They can be python variables or logic variables</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">eq_goal</span>(s):
        <span style="color: #DFAF8F;">s</span> = unify(u, v, s)
        <span style="color: #F0DFAF; font-weight: bold;">if</span> s <span style="color: #F0DFAF; font-weight: bold;">is</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #BFEBBF;">False</span>:
            <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #DCDCCC; font-weight: bold;">iter</span>((s,))
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #DCDCCC; font-weight: bold;">iter</span>(())

    <span style="color: #F0DFAF; font-weight: bold;">return</span> eq_goal
</pre>
</div>

<p>
Initial state is the empty dictionary <code>{}</code>. Then what <code>run</code> does is reifying the input variable with whatever
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">q</span> = var(<span style="color: #CC9393;">'q'</span>)
<span style="color: #DFAF8F;">goal</span> = eq(q, 1)
<span style="color: #DFAF8F;">res</span> = <span style="color: #DCDCCC; font-weight: bold;">next</span>(goal({}))
reify(q, res)
</pre>
</div>

<p>
is equivalent to the following:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> kanren <span style="color: #F0DFAF; font-weight: bold;">import</span> var, run, eq

<span style="color: #DFAF8F;">q</span> = var(<span style="color: #CC9393;">'q'</span>)
<span style="color: #DFAF8F;">res</span> = run(0, q, eq(q, 1.))
<span style="color: #F0DFAF; font-weight: bold;">print</span>(res[0])
</pre>
</div>

<p>
So far so good, nothing exceptional here. Difficulty comes when we add logic to combine goals.
</p>
</div>
</div>

<div id="outline-container-org2db6d72" class="outline-2">
<h2 id="org2db6d72">Combining goals</h2>
<div class="outline-text-2" id="text-org2db6d72">
</div>
<div id="outline-container-orgecb5c35" class="outline-3">
<h3 id="orgecb5c35">Conjunction of goals</h3>
<div class="outline-text-3" id="text-orgecb5c35">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">conj</span>(goal1, goal2):

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">and_goal</span>(S):
        <span style="color: #DFAF8F;">S1</span> = goal1(S)
        <span style="color: #F0DFAF; font-weight: bold;">yield</span> <span style="color: #F0DFAF; font-weight: bold;">from</span> <span style="color: #DCDCCC; font-weight: bold;">map</span>(goal2, S1)

    <span style="color: #F0DFAF; font-weight: bold;">return</span> and_goal
</pre>
</div>

<p>
So we can now use our <code>eq</code> operator defined above. This is where the possibility to pass a <code>state</code> to <code>unify</code> shows its usefulness:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">goal1</span> = eq(q, 2)
<span style="color: #DFAF8F;">goal2</span> = eq(q, 3)

<span style="color: #DFAF8F;">state1</span> = <span style="color: #DCDCCC; font-weight: bold;">next</span>(goal1({}))
<span style="color: #F0DFAF; font-weight: bold;">print</span>(state1)

<span style="color: #DFAF8F;">state2</span> = <span style="color: #DCDCCC; font-weight: bold;">next</span>(goal2({}))
<span style="color: #F0DFAF; font-weight: bold;">print</span>(state2)

<span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">next</span>(goal2({q: 3})))
<span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #DCDCCC; font-weight: bold;">next</span>(goal2({q: 2})))
</pre>
</div>

<p>
Yep, if the state is incompatible then the iterator has nothing to offer. This looks like the following:
</p>

<div class="org-src-container">
<pre class="src src-ascii">| goal1 | ---&gt; unified state1 ---&gt; | goal2 | ---&gt; unified state compatible with state1
</pre>
</div>

<p>
<i>Unify does all the work here</i>.
</p>
</div>
</div>

<div id="outline-container-org4485630" class="outline-3">
<h3 id="org4485630">Disjunctions of goals</h3>
<div class="outline-text-3" id="text-org4485630">
<p>
Here we just interleave results. Both branches are contributing possible states. The current implementation uses a naive interleaving mechanism.
</p>
</div>
</div>

<div id="outline-container-org260fa2a" class="outline-3">
<h3 id="org260fa2a">Conditional</h3>
</div>
<div id="outline-container-org33f29d9" class="outline-3">
<h3 id="org33f29d9">Negations</h3>
</div>
</div>
</div>
</body>
</html>