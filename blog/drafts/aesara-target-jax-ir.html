<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-02 Fri 09:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Target JAX's intermediate representation with Aesara</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Target JAX's intermediate representation with Aesara</h1>
<p>
There are several questions we need to answer:
</p>
<ol class="org-ol">
<li>Is it helping with anything? (example )</li>
<li>Can we implement loops directly in Jaxprs?</li>
<li>Can we JIT the resulting functions?</li>
<li>Can we <code>vmap</code> the resulting functions?</li>
<li>Can we <code>grad</code> the following functions?</li>
</ol>

<div id="outline-container-org0f1894e" class="outline-2">
<h2 id="org0f1894e">Issues we'd like to solve</h2>
<div class="outline-text-2" id="text-org0f1894e">
<p>
The following fails even though it has static shape:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> functools

<span style="font-weight: bold;">import</span> jax
<span style="font-weight: bold;">import</span> jax.numpy <span style="font-weight: bold;">as</span> jnp
<span style="font-weight: bold;">from</span> jax <span style="font-weight: bold;">import</span> make_jaxpr

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">d</span>(y, z):
    <span style="font-weight: bold;">return</span> jnp.shape(y)[z]

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">c</span>(y, z):
    <span style="font-weight: bold;">return</span> jnp.where(d(y, 0) / z &gt; 0, d(y, 0) / z, 0)

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">b</span>(y):
    <span style="font-weight: bold;">return</span> [c(y, 2), c(y, 3)]

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">a</span>(y):
    <span style="font-weight: bold;">return</span> jnp.reshape(y, b(y))

<span style="font-weight: bold; font-style: italic;">a_jaxpr</span> = make_jaxpr(a)(jnp.array([1., 1.]))
a_jaxpr
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">TypeError: Shapes must be 1D sequences of concrete values of integer type, got [Traced&lt;ShapedArray(float32[], weak_type=True)&gt;with&lt;DynamicJaxprTrace(level=1/0)&gt;, Traced&lt;ShapedArray(float32[], weak_type=True)&gt;with&lt;DynamicJaxprTrace(level=1/0)&gt;].</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">If using `jit`, try using `static_argnums` or applying `jit` to smaller subfunctions.</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> jax.numpy <span style="font-weight: bold;">as</span> jnp
<span style="font-weight: bold;">from</span> jax <span style="font-weight: bold;">import</span> make_jaxpr

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">a</span>(x, y):
    <span style="font-weight: bold;">return</span> jnp.reshape(x, y)

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">b</span>(x):
    <span style="font-weight: bold;">return</span> jnp.reshape(x, (1,2))

<span style="font-weight: bold;">try</span>:
    <span style="font-weight: bold; font-style: italic;">a_jaxpr</span> = make_jaxpr(a)(jnp.array([1., 1.]), [0, 1])
<span style="font-weight: bold;">except</span> <span style="font-weight: bold; text-decoration: underline;">Exception</span> <span style="font-weight: bold;">as</span> e:
    <span style="font-weight: bold;">print</span>(e)

<span style="font-weight: bold;">try</span>:
    <span style="font-weight: bold; font-style: italic;">b_jaxpr</span> = make_jaxpr(b)(jnp.array([1., 1.]))
    <span style="font-weight: bold;">print</span>(b_jaxpr)
<span style="font-weight: bold;">except</span> <span style="font-weight: bold; text-decoration: underline;">Exception</span> <span style="font-weight: bold;">as</span> e:
    <span style="font-weight: bold;">print</span>(e)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> functools <span style="font-weight: bold;">as</span> ft
<span style="font-weight: bold;">import</span> jax
<span style="font-weight: bold;">import</span> jax.numpy <span style="font-weight: bold;">as</span> jnp
<span style="font-weight: bold;">from</span> jax <span style="font-weight: bold;">import</span> make_jaxpr

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">ex1</span>(x):
  <span style="font-weight: bold; font-style: italic;">size</span> = jnp.prod(jnp.array(x.shape))
  <span style="font-weight: bold;">return</span> x.reshape((size,))

<span style="font-weight: bold;">try</span>:
    <span style="font-weight: bold; font-style: italic;">a_jaxpr</span> = make_jaxpr(ex1)(jnp.array([1., 1.]))
<span style="font-weight: bold;">except</span> <span style="font-weight: bold; text-decoration: underline;">Exception</span> <span style="font-weight: bold;">as</span> e:
    <span style="font-weight: bold;">print</span>(e)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7117fa5" class="outline-2">
<h2 id="org7117fa5"><span class="todo TODO">TODO</span> Can we use dyanic values as arguments to <code>reshape</code> in the JAXprs?</h2>
<div class="outline-text-2" id="text-org7117fa5">
<p>
Take this one:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> jax.numpy <span style="font-weight: bold;">as</span> jnp
<span style="font-weight: bold;">from</span> jax <span style="font-weight: bold;">import</span> make_jaxpr

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">b</span>(x):
    <span style="font-weight: bold;">return</span> jnp.reshape(x, (1,2))

<span style="font-weight: bold; font-style: italic;">b_jaxpr</span> = make_jaxpr(b)(jnp.array([1., 1.]))
<span style="font-weight: bold;">print</span>(b_jaxpr)
<span style="font-weight: bold;">print</span>(b_jaxpr.eqns[0])
<span style="font-weight: bold;">print</span>(b_jaxpr.eqns[0].primitive)
<span style="font-weight: bold;">print</span>(b_jaxpr.eqns[0].invars)
<span style="font-weight: bold;">print</span>(b_jaxpr.eqns[0].params)
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc075fd3" class="outline-2">
<h2 id="orgc075fd3">JIT-ing functions built from JAXprs</h2>
<div class="outline-text-2" id="text-orgc075fd3">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> jax
<span style="font-weight: bold;">from</span> jax <span style="font-weight: bold;">import</span> lax
<span style="font-weight: bold;">from</span> jax <span style="font-weight: bold;">import</span> make_jaxpr


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">add_fn</span>(a, b):
    <span style="font-weight: bold;">return</span> lax.add(a, b)

<span style="font-weight: bold; font-style: italic;">add_jaxpr</span> = jax.make_jaxpr(add_fn)(1., 1.)
<span style="font-weight: bold;">print</span>(add_jaxpr)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">{ lambda ; a:f32[] b:f32[]. let c:f32[] = add a b in (c,) }</span>

<span style="font-weight: bold;">from</span> jax.core <span style="font-weight: bold;">import</span> jaxpr_as_fun
<span style="font-weight: bold; font-style: italic;">add_1d</span> = jaxpr_as_fun(add_jaxpr)
<span style="font-weight: bold; font-style: italic;">jitted_add_1d</span> = jax.jit(add_1d)
<span style="font-weight: bold;">print</span>(jitted_add_1d)
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">&lt;CompiledFunction of functools.partial(&lt;function jaxpr_as_fun at 0x7fa8e7551990&gt;, { lambda ; a:f32[] b:f32[]. let c:f32[] = add a b in (c,) })&gt;</span>

<span style="font-weight: bold; font-style: italic;">jitted_add_1d_jaxpr</span> = make_jaxpr(jitted_add_1d)(1., 1.)
<span style="font-weight: bold;">print</span>(jitted_add_1d_jaxpr)
</pre>
</div>

<ul class="org-ul">
<li>What is the definition of <code>jaxpr_as_fun</code>?</li>
<li>What is a <code>CompiledFunction</code>?</li>
</ul>
</div>
</div>

<div id="outline-container-org201e946" class="outline-2">
<h2 id="org201e946">VMAP-ing functions built from JAXprs</h2>
<div class="outline-text-2" id="text-org201e946">
<p>
We can vmap the function produced by <code>jaxpr_as_fun</code>, <i>but</i> we cannot indicate vmapped in Jaxpr
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> jax.numpy <span style="font-weight: bold;">as</span> jnp

<span style="font-weight: bold; font-style: italic;">vmapped_add_1d</span> = jax.vmap(add_1d, in_axes=(0, 0))
<span style="font-weight: bold;">print</span>(vmapped_add_1d)

<span style="font-weight: bold; font-style: italic;">vmapped_add_1d_jaxpr</span> = make_jaxpr(vmapped_add_1d)(jnp.array([1., 1.]), jnp.array([1., 1.]))
<span style="font-weight: bold;">print</span>(vmapped_add_1d_jaxpr)


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">my_func</span>(a):
    <span style="font-weight: bold; font-style: italic;">b</span> = jax.vmap(add_fn, in_axes=(1, 1))(a, a)
    <span style="font-weight: bold;">return</span> b

<span style="font-weight: bold;">print</span>(make_jaxpr(my_func)(jnp.array([[1., 2., 3.], [1., 2., 3.]])))
</pre>
</div>

<ul class="org-ul">
<li>Can we indicate vmapping operation in the JAxpr?</li>
<li>Is it because XLA automatically SIMD runs this stuff, and `vmap` is simply a way to "box" it, i.e. encode in code the rules that lead to SIMD execution?</li>
</ul>
</div>
</div>

<div id="outline-container-org0423acf" class="outline-2">
<h2 id="org0423acf">Grad-ing functions built from Jaxprs</h2>
<div class="outline-text-2" id="text-org0423acf">
<p>
This one is interesting, but less critical since Aesara can compile gradient graphs.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">grad_add_1d</span> = jax.grad(add_1d)
<span style="font-weight: bold;">print</span>(grad_add_1_d)

<span style="font-weight: bold;">try</span>:
    <span style="font-weight: bold; font-style: italic;">grad_add_1d_jaxpr</span> = make_jaxpr(grad_add_1d)(1., 1.)
<span style="font-weight: bold;">except</span> <span style="font-weight: bold; text-decoration: underline;">Exception</span> <span style="font-weight: bold;">as</span> e:
    <span style="font-weight: bold;">print</span>(e)
</pre>
</div>
</div>
</div>
</div>
</body>
</html>