<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-12-01 Thu 10:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Find horsehoe priors in an Aesara graph</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Find horsehoe priors in an Aesara graph</h1>
<p>
In this short post we will try to unify subgraphs of an <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aesara">Aesara</a> graph with a pattern that represents a horseshoe prior, a generalization of <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/aesara-devs/aemcmc/blob/0a8cc0044f76e39f49716107cdc77b210832c44a/aemcmc/gibbs.py#L90">this unification in Aemcmc</a>. We will consider the following negative binomial regresssion throughout:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">import</span> aesara.tensor <span style="color: #d73a49;">as</span> at

<span style="color: #24292e;">srng</span> = at.random.RandomStream(0)

<span style="color: #24292e;">X_tt</span> = at.matrix(<span style="color: #032f62;">'X'</span>)
<span style="color: #24292e;">h_tt</span> = at.scalar(<span style="color: #032f62;">'h'</span>, dtype=<span style="color: #032f62;">"int32"</span>)

<span style="color: #24292e;">tau_rv</span> = srng.halfcauchy(1, size=1)
<span style="color: #24292e;">lmbda_rv</span> = srng.halfcauchy(1, size=10)
<span style="color: #24292e;">beta_rv</span> = srng.normal(0, tau_rv * lmbda_rv)

<span style="color: #24292e;">eta</span> = X_tt @ beta_rv
<span style="color: #24292e;">p</span> = at.sigmoid(-eta)
<span style="color: #24292e;">Y_rv</span> = srng.nbinom(h_tt, p)
</pre>
</div>

<div id="outline-container-org49ae84c" class="outline-2">
<h2 id="org49ae84c">Unification on the graphical structure</h2>
<div class="outline-text-2" id="text-org49ae84c">
<p>
Remember that the horseshoe prior is mathematically defined as:
</p>

<div class="latex" id="orga4e4a5c">
\begin{align*}
  \tau &\sim \operatorname{HalfCauchy}(0, 1)\\
  \lambda_{j} &\sim \operatorname{HalfCauchy}(0, 1)\quad j \in \left[1,\dots, k\right]\\
  \beta_{j} &\sim \operatorname{Normal}(0, \tau \;\lambda_{j})\quad j \in \left[1,\dots, k\right]\\
\end{align*}

</div>

<p>
We would like to be able to tell whether the model that the graph implements contains a horseshoe prior, and if so return the variables that represent \(\lambda\) and \(\tau\). We start by define a horseshoe pattern against which we are going to try to match the model, using <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/pythological/unification">unification</a>'s logic variables and <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/pythological/etuples">etuples</a>' emulation of S-expressions:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> unification <span style="color: #d73a49;">import</span> var
<span style="color: #d73a49;">from</span> etuples <span style="color: #d73a49;">import</span> etuple, etuplize

<span style="color: #24292e;">horseshoe_1_lv</span>, <span style="color: #24292e;">horseshoe_2_lv</span> = var(<span style="color: #032f62;">'horseshoe_1'</span>), var(<span style="color: #032f62;">'horsehoe_2'</span>)
<span style="color: #24292e;">zero_lv</span> = var(<span style="color: #032f62;">'zero'</span>)
<span style="color: #24292e;">horseshoe_pattern</span> = etuple(
    etuplize(at.random.normal),
    var(),
    var(),
    var(),
    zero_lv,
    etuple(
        etuplize(at.mul),
        horseshoe_1_lv,
        horseshoe_2_lv)
)
</pre>
</div>

<p>
We can then unify this pattern with the subgraph <code>beta_rv</code> using pythological's <a target='_blank' rel='noopener noreferrer' class='external' href="https://github.com/pythological/unification">unification</a> package:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> unification <span style="color: #d73a49;">import</span> unify
<span style="color: #d73a49;">from</span> IPython.lib.pretty <span style="color: #d73a49;">import</span> pprint

<span style="color: #24292e;">s</span> = unify(horseshoe_pattern, etuplize(beta_rv))
pprint(s)
</pre>
</div>

<pre class="example" id="org2795ab6">
{~_32: RandomGeneratorSharedVariable(&lt;Generator(PCG64) at 0x7FCCBFFD8740&gt;),
 ~_33: TensorConstant{[]},
 ~_34: TensorConstant{11},
 ~zero: TensorConstant{0},
 ~horseshoe_1: e(
   e(
     aesara.tensor.random.basic.HalfCauchyRV,
     'halfcauchy',
     0,
     (0, 0),
     'floatX',
     False),
   RandomGeneratorSharedVariable(&lt;Generator(PCG64) at 0x7FCCBFFD8F20&gt;),
   TensorConstant{(1,) of 1},
   TensorConstant{11},
   TensorConstant{1},
   TensorConstant{1.0}),
 ~horsehoe_2: e(
   e(
     aesara.tensor.random.basic.HalfCauchyRV,
     'halfcauchy',
     0,
     (0, 0),
     'floatX',
     False),
   RandomGeneratorSharedVariable(&lt;Generator(PCG64) at 0x7FCCBFFCB820&gt;),
   TensorConstant{(1,) of 10},
   TensorConstant{11},
   TensorConstant{1},
   TensorConstant{1.0})}
</pre>
</div>
</div>


<div id="outline-container-org28255ee" class="outline-2">
<h2 id="org28255ee">Model unification</h2>
<div class="outline-text-2" id="text-org28255ee">
<p>
The pattern we used in the previous section only checks that the <i>graphical structure</i> matches the horseshoe prior, but not that the correct distributions and correct parameters are used. However, we can only identify an aesara graph with the mathematical model if structure <i>and</i> distributions match (or if the pattern represents the normal form of the model under a set of rewrite rules, but we'll keep things simple for now).
</p>

<p>
Let us thus improve the design by defining a <code>unify_horseshoe</code> function that not only checks the basic graphical structure but also the shapes and distributions. This function behaves similarly to <code>unify</code>; it returns the random variables <code>(lambda_rv, tau_rv)</code> when the subgraph is identified, and <code>False</code> if unification is impossible.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> aesara.graph.unify <span style="color: #d73a49;">import</span> eval_if_etuple
<span style="color: #d73a49;">from</span> etuples <span style="color: #d73a49;">import</span> etuple, etuplize
<span style="color: #d73a49;">from</span> unification <span style="color: #d73a49;">import</span> unify, var

<span style="color: #d73a49;">def</span> <span style="color: #6f42c1;">unify_horseshoe</span>(graph):
    <span style="color: #24292e;">horseshoe_1_lv</span>, <span style="color: #24292e;">horseshoe_2_lv</span> = var(<span style="color: #032f62;">'horseshoe_1'</span>), var(<span style="color: #032f62;">'horsehoe_2'</span>)
    <span style="color: #24292e;">zero_lv</span> = var(<span style="color: #032f62;">'zero'</span>)
    <span style="color: #24292e;">horseshoe_pattern</span> = etuple(
        etuplize(at.random.normal),
        var(),
        var(),
        var(),
        zero_lv,
        etuple(
            etuplize(at.mul),
            horseshoe_1_lv,
            horseshoe_2_lv)
    )

    <span style="color: #24292e;">s</span> = unify(graph, horseshoe_pattern)
    <span style="color: #d73a49;">if</span> s <span style="color: #d73a49;">is</span> <span style="color: #005cc5;">False</span>:
        <span style="color: #d73a49;">return</span> <span style="color: #005cc5;">False</span>

    <span style="color: #6a737d;"># </span><span style="color: #6a737d;">Check that horseshoe_1 was unified with a half-cauchy distributed RV</span>
    <span style="color: #24292e;">halfcauchy_1</span> = eval_if_etuple(s[horseshoe_1_lv])
    <span style="color: #d73a49;">if</span> halfcauchy_1.owner <span style="color: #d73a49;">is</span> <span style="color: #005cc5;">None</span> <span style="color: #d73a49;">or</span> <span style="color: #d73a49;">not</span> <span style="color: #d73a49;">isinstance</span>(
        halfcauchy_1.owner.op, <span style="color: #d73a49;">type</span>(at.random.halfcauchy)
    ):
         <span style="color: #d73a49;">return</span> <span style="color: #005cc5;">False</span>

    <span style="color: #6a737d;"># </span><span style="color: #6a737d;">Check that horseshoe_2 was unified with a half-cauchy distributed RV</span>
    <span style="color: #24292e;">halfcauchy_2</span> = eval_if_etuple(s[horseshoe_2_lv])
    <span style="color: #d73a49;">if</span> halfcauchy_2.owner <span style="color: #d73a49;">is</span> <span style="color: #005cc5;">None</span> <span style="color: #d73a49;">or</span> <span style="color: #d73a49;">not</span> <span style="color: #d73a49;">isinstance</span>(
        halfcauchy_2.owner.op, <span style="color: #d73a49;">type</span>(at.random.halfcauchy)
    ):
        <span style="color: #d73a49;">return</span> <span style="color: #005cc5;">False</span>
    <span style="color: #6a737d;"># </span><span style="color: #6a737d;">Check that at least one of the RVs is a scalar</span>
    <span style="color: #d73a49;">if</span> halfcauchy_1.<span style="color: #d73a49;">type</span>.shape == (1,):
        <span style="color: #24292e;">lmbda_rv</span> = halfcauchy_2
        <span style="color: #24292e;">tau_rv</span> = halfcauchy_1
    <span style="color: #d73a49;">elif</span> halfcauchy_2.<span style="color: #d73a49;">type</span>.shape == (1,):
        <span style="color: #24292e;">lmbda_rv</span> = halfcauchy_1
        <span style="color: #24292e;">tau_rv</span> = halfcauchy_2
    <span style="color: #d73a49;">else</span>:
        <span style="color: #d73a49;">return</span> false

    <span style="color: #d73a49;">return</span> (lmbda_rv, tau_rv)
</pre>
</div>

<p>
Again we check that we can unify the subgraph <code>beta_rv</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">print</span>(unify_horseshoe(beta_rv))
</pre>
</div>

<pre class="example">
(halfcauchy_rv{0, (0, 0), floatX, False}.out, halfcauchy_rv{0, (0, 0), floatX, False}.out)
</pre>
</div>
</div>


<div id="outline-container-org23aca83" class="outline-2">
<h2 id="org23aca83">Walk the graph</h2>
<div class="outline-text-2" id="text-org23aca83">
<p>
<code>unify_horseshoe</code> will only work if the pattern matches the whole graph. Indeed if we try to unify the horsehoe pattern with <code>Y_rv</code> we get:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">print</span>(unify_horseshoe(Y_rv))
</pre>
</div>

<pre class="example">
False
</pre>


<p>
To identify subgraphs we thus need to walk through the graph (here breadth-first) and attempt unification at each step:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #d73a49;">from</span> aesara.graph.basic <span style="color: #d73a49;">import</span> walk
<span style="color: #d73a49;">from</span> aesara.tensor.random.op <span style="color: #d73a49;">import</span> RandomVariable

<span style="color: #d73a49;">def</span> <span style="color: #6f42c1;">expand</span>(var):
    <span style="color: #d73a49;">if</span> var.owner:
        <span style="color: #d73a49;">return</span> var.owner.inputs
    <span style="color: #d73a49;">else</span>:
        <span style="color: #d73a49;">return</span>

<span style="color: #d73a49;">for</span> node <span style="color: #d73a49;">in</span> walk([Y_rv], expand, bfs=<span style="color: #005cc5;">True</span>):
    <span style="color: #d73a49;">try</span>:
        <span style="color: #d73a49;">if</span> <span style="color: #d73a49;">isinstance</span>(node.owner.op, RandomVariable):
            <span style="color: #24292e;">s</span> = unify_horseshoe(node)
            <span style="color: #d73a49;">if</span> s:
                <span style="color: #d73a49;">break</span>
    <span style="color: #d73a49;">except</span> <span style="color: #005cc5;">AttributeError</span>:
        <span style="color: #d73a49;">continue</span>
</pre>
</div>

<p>
We can check that \(\tau\) and \(\lambda\) have been correctly identified:
</p>

<div class="org-src-container">
<pre class="src src-python">pprint(s)
</pre>
</div>

<pre class="example">
(halfcauchy_rv{0, (0, 0), floatX, False}.out,
 halfcauchy_rv{0, (0, 0), floatX, False}.out)
</pre>


<p>
Being able to unify a pattern with a subgraph is a (small) first step towards being able to assign sampling steps to random variables in an arbitrary graph. In the following post we will show how we can automatically build a Gibbs sampler for (sub)graphs that represent a horseshoe prior.
</p>
</div>
</div>
</div>
</body>
</html>