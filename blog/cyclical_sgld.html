<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-02-02 Thu 12:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cyclical SGLD in Blackjax</title>
<meta name="author" content="RÃ©mi Louf" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Cyclical SGLD in Blackjax</h1>

<div id="outline-container-org842e8a2" class="outline-3">
<h3 id="org842e8a2">Cyclical schedule</h3>
<div class="outline-text-3" id="text-org842e8a2">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> typing <span style="color: #F0DFAF; font-weight: bold;">import</span> NamedTuple


<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">ScheduleState</span>(NamedTuple):
    step_size: <span style="color: #DCDCCC; font-weight: bold;">float</span>
    do_sample: <span style="color: #DCDCCC; font-weight: bold;">bool</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">build_schedule</span>(
    num_training_steps,
    num_cycles=4,
    initial_step_size=1e-3,
    exploration_ratio=0.25,
):
    <span style="color: #DFAF8F;">cycle_length</span> = num_training_steps // num_cycles

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">schedule_fn</span>(step_id):
        <span style="color: #DFAF8F;">do_sample</span> = <span style="color: #BFEBBF;">False</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> ((step_id % cycle_length)/cycle_length) &gt;= exploration_ratio:
            <span style="color: #DFAF8F;">do_sample</span> = <span style="color: #BFEBBF;">True</span>

        <span style="color: #DFAF8F;">cos_out</span> = jnp.cos(jnp.pi * (step_id % cycle_length) / cycle_length) + 1
        <span style="color: #DFAF8F;">step_size</span> = 0.5 * cos_out * initial_step_size

        <span style="color: #F0DFAF; font-weight: bold;">return</span> ScheduleState(step_size, do_sample)

    <span style="color: #F0DFAF; font-weight: bold;">return</span> schedule_fn
</pre>
</div>

<p>
Let us visualize the schedule for 200k training steps divided in 4 cycles. At each cycle 1/4th of the steps are dedicated to exploration.
</p>


<div id="org7b551d9" class="figure">
<p><img src="img/cyclical_sgld_schedule.png" alt="cyclical_sgld_schedule.png" width="100%" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgd72aa60" class="outline-3">
<h3 id="orgd72aa60">Cyclical SGLD step</h3>
<div class="outline-text-3" id="text-orgd72aa60">
<p>
We will reproduce one of the paper's example, sampling from an array of 25 gaussians.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> itertools

<span style="color: #F0DFAF; font-weight: bold;">import</span> jax
<span style="color: #F0DFAF; font-weight: bold;">import</span> jax.scipy <span style="color: #F0DFAF; font-weight: bold;">as</span> jsp
<span style="color: #F0DFAF; font-weight: bold;">import</span> jax.numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> jnp


<span style="color: #DFAF8F;">lmbda</span> = 1/25
<span style="color: #DFAF8F;">positions</span> = [-4, -2, 0, 2, 4]
<span style="color: #DFAF8F;">mu</span> = jnp.array([<span style="color: #DCDCCC; font-weight: bold;">list</span>(prod) <span style="color: #F0DFAF; font-weight: bold;">for</span> prod <span style="color: #F0DFAF; font-weight: bold;">in</span> itertools.product(positions, positions)])
<span style="color: #DFAF8F;">sigma</span> = 0.03 * jnp.eye(2)

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">logprob_fn</span>(x, *_):
    <span style="color: #F0DFAF; font-weight: bold;">return</span> lmbda * jsp.special.logsumexp(
        jax.scipy.stats.multivariate_normal.logpdf(x, mu, sigma)
    )

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">sample_fn</span>(rng_key):
    <span style="color: #DFAF8F;">choose_key</span>, <span style="color: #DFAF8F;">sample_key</span> = jax.random.split(rng_key)
    <span style="color: #DFAF8F;">samples</span> = jax.random.multivariate_normal(sample_key, mu, sigma)
    <span style="color: #F0DFAF; font-weight: bold;">return</span> jax.random.choice(choose_key, samples)
</pre>
</div>

<p>
Let's plot the model's density; we will need the plot later to evaluate the sampler
</p>


<div id="org1322a7b" class="figure">
<p><img src="img/cyclical_sgld_array_gaussians.png" alt="cyclical_sgld_array_gaussians.png" width="100%" />
</p>
</div>
</div>
</div>


<div id="outline-container-org8691cbc" class="outline-3">
<h3 id="org8691cbc">Sample from the mixture of gaussians</h3>
<div class="outline-text-3" id="text-org8691cbc">
<p>
The sampling kernel must be able to alternate between sampling and optimization periods that are determined by the scheduler.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">from</span> typing <span style="color: #F0DFAF; font-weight: bold;">import</span> NamedTuple

<span style="color: #F0DFAF; font-weight: bold;">import</span> blackjax
<span style="color: #F0DFAF; font-weight: bold;">import</span> optax

<span style="color: #F0DFAF; font-weight: bold;">from</span> blackjax.types <span style="color: #F0DFAF; font-weight: bold;">import</span> PyTree
<span style="color: #F0DFAF; font-weight: bold;">from</span> optax._src.base <span style="color: #F0DFAF; font-weight: bold;">import</span> OptState


<span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">CyclicalSGMCMCState</span>(NamedTuple):
    <span style="color: #9FC59F;">"""State of the Cyclical SGMCMC sampler."""</span>
    position: PyTree
    opt_state: OptState


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">cyclical_sgld</span>(grad_estimator_fn, loglikelihood_fn):

    <span style="color: #DFAF8F;">sgld</span> = blackjax.sgld(grad_estimator_fn)
    <span style="color: #DFAF8F;">sgd</span> = optax.sgd(1.)

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">init_fn</span>(position):
        <span style="color: #9FC59F;">"""Initialize Cyclical SGLD's state."""</span>
        <span style="color: #DFAF8F;">opt_state</span> = sgd.init(position)
        <span style="color: #F0DFAF; font-weight: bold;">return</span> CyclicalSGMCMCState(position, opt_state)

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">step_fn</span>(
        rng_key,
        schedule_state: ScheduleState,
        state: CyclicalSGMCMCState,
        minibatch: PyTree
    ):
        <span style="color: #9FC59F;">"""Cyclical SGLD kernel.</span>

<span style="color: #9FC59F;">        TODO: Organize the inputs to match the SGLD API better.</span>

<span style="color: #9FC59F;">        rng_key</span>
<span style="color: #9FC59F;">            Key for JAX's pseudo-random number generator.</span>
<span style="color: #9FC59F;">        schedule_state</span>
<span style="color: #9FC59F;">            The current state of the scheduler. Indicates whether the kernel</span>
<span style="color: #9FC59F;">            should be sampling or optimizing, and the current step size.</span>
<span style="color: #9FC59F;">        state</span>
<span style="color: #9FC59F;">            The current state of the Cyclical SGLD sampler.</span>
<span style="color: #9FC59F;">        minibatch</span>
<span style="color: #9FC59F;">            Not used in the mixture example, but this is where you would pass</span>
<span style="color: #9FC59F;">            batches of data in any real application.</span>

<span style="color: #9FC59F;">        """</span>

        <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">step_with_sgld</span>(current_state):
            <span style="color: #DFAF8F;">rng_key</span>, <span style="color: #DFAF8F;">state</span>, <span style="color: #DFAF8F;">minibatch</span>, <span style="color: #DFAF8F;">step_size</span> = current_state
            <span style="color: #DFAF8F;">new_position</span> = sgld(rng_key, state.position, minibatch, step_size)
            <span style="color: #F0DFAF; font-weight: bold;">return</span> CyclicalSGMCMCState(new_position, state.opt_state)

        <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">step_with_sgd</span>(current_state):
            <span style="color: #DFAF8F;">_</span>, <span style="color: #DFAF8F;">state</span>, <span style="color: #DFAF8F;">minibatch</span>, <span style="color: #DFAF8F;">step_size</span> = current_state
            <span style="color: #DFAF8F;">grads</span> = grad_estimator_fn(state.position, minibatch)
            <span style="color: #DFAF8F;">rescaled_grads</span> = - 1. * step_size * grads
            <span style="color: #DFAF8F;">updates</span>, <span style="color: #DFAF8F;">new_opt_state</span> = sgd.update(rescaled_grads, state.opt_state, state.position)
            <span style="color: #DFAF8F;">new_position</span> = optax.apply_updates(state.position, updates)
            <span style="color: #F0DFAF; font-weight: bold;">return</span> CyclicalSGMCMCState(new_position, new_opt_state)

        <span style="color: #DFAF8F;">new_state</span> = jax.lax.cond(
            schedule_state.do_sample,
            step_with_sgld,
            step_with_sgd,
            (rng_key, state, minibatch, schedule_state.step_size)
        )

        <span style="color: #F0DFAF; font-weight: bold;">return</span> new_state

    <span style="color: #F0DFAF; font-weight: bold;">return</span> init_fn, step_fn
</pre>
</div>
</div>
</div>


<div id="outline-container-orga07aa17" class="outline-3">
<h3 id="orga07aa17">SGLD</h3>
<div class="outline-text-3" id="text-orga07aa17">
<p>
Let's start with SGLD:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> jax
<span style="color: #F0DFAF; font-weight: bold;">from</span> fastprogress <span style="color: #F0DFAF; font-weight: bold;">import</span> progress_bar

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">50k iterations</span>
<span style="color: #DFAF8F;">num_training_steps</span> = 50000
<span style="color: #DFAF8F;">schedule_fn</span> = <span style="color: #F0DFAF; font-weight: bold;">lambda</span> k: 0.05 * k ** (-0.55)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">TODO: There is no need to pre-compute the schedule</span>
<span style="color: #DFAF8F;">schedule</span> = [schedule_fn(i) <span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(1, num_training_steps+1)]

<span style="color: #DFAF8F;">grad_fn</span> = <span style="color: #F0DFAF; font-weight: bold;">lambda</span> x, _: jax.grad(logprob_fn)(x)
<span style="color: #DFAF8F;">sgld</span> = blackjax.sgld(grad_fn)

<span style="color: #DFAF8F;">rng_key</span> = jax.random.PRNGKey(3)
<span style="color: #DFAF8F;">init_position</span> = -10 + 20 * jax.random.uniform(rng_key, shape=(2,))

<span style="color: #DFAF8F;">position</span> = init_position
<span style="color: #DFAF8F;">sgld_samples</span> = []
<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> progress_bar(<span style="color: #DCDCCC; font-weight: bold;">range</span>(num_training_steps)):
    <span style="color: #DFAF8F;">_</span>, <span style="color: #DFAF8F;">rng_key</span> = jax.random.split(rng_key)
    <span style="color: #DFAF8F;">position</span> = jax.jit(sgld)(rng_key, position, 0, schedule[i])
    sgld_samples.append(position)
</pre>
</div>

<p>
Let's plot the trajectory:
</p>


<div id="org99603f3" class="figure">
<p><img src="img/cyclical_sgld_sgld_samples.png" alt="cyclical_sgld_sgld_samples.png" width="70%" />
</p>
</div>
</div>
</div>


<div id="outline-container-orgaf29557" class="outline-3">
<h3 id="orgaf29557">Cyclical SGLD</h3>
<div class="outline-text-3" id="text-orgaf29557">
<p>
Now let's sample using Cyclical SGLD.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> jax
<span style="color: #F0DFAF; font-weight: bold;">from</span> fastprogress <span style="color: #F0DFAF; font-weight: bold;">import</span> progress_bar

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">50k iterations</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">M = 30</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">initial step size = 0.09</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">ratio exploration = 1/4</span>
<span style="color: #DFAF8F;">num_training_steps</span> = 50000
<span style="color: #DFAF8F;">schedule_fn</span> = build_schedule(num_training_steps, 30, 0.09, 0.25)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">TODO: There is no need to pre-compute the schedule</span>
<span style="color: #DFAF8F;">schedule</span> = [schedule_fn(i) <span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(num_training_steps)]

<span style="color: #DFAF8F;">grad_fn</span> = <span style="color: #F0DFAF; font-weight: bold;">lambda</span> x, _: jax.grad(logprob_fn)(x)
<span style="color: #DFAF8F;">init</span>, <span style="color: #DFAF8F;">step</span> = cyclical_sgld(grad_fn, logprob_fn)

<span style="color: #DFAF8F;">rng_key</span> = jax.random.PRNGKey(3)
<span style="color: #DFAF8F;">init_position</span> = -10 + 20 * jax.random.uniform(rng_key, shape=(2,))
<span style="color: #DFAF8F;">init_state</span> = init(init_position)


<span style="color: #DFAF8F;">state</span> = init_state
<span style="color: #DFAF8F;">cyclical_samples</span> = []
<span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> progress_bar(<span style="color: #DCDCCC; font-weight: bold;">range</span>(num_training_steps)):
    <span style="color: #DFAF8F;">_</span>, <span style="color: #DFAF8F;">rng_key</span> = jax.random.split(rng_key)
    <span style="color: #DFAF8F;">state</span> = jax.jit(step)(rng_key, schedule[i], state, 0)
    <span style="color: #F0DFAF; font-weight: bold;">if</span> schedule[i].do_sample:
        cyclical_samples.append(state.position)
</pre>
</div>

<p>
It looks from the trajectory that the distribution is better explored:
</p>


<div id="org214e3de" class="figure">
<p><img src="img/cyclical_sgld_samples.png" alt="cyclical_sgld_samples.png" width="70%" />
</p>
</div>

<p>
Let's look at the distribution:
</p>


<div id="orgce740d0" class="figure">
<p><img src="img/cyclical_sgld_distribution.png" alt="cyclical_sgld_distribution.png" width="70%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org0986503" class="outline-2">
<h2 id="org0986503">What's next</h2>
<div class="outline-text-2" id="text-org0986503">
<ul class="org-ul">
<li>As Adrien Corenflos noted, Scott's rule for KDE assumes that the total number of points is the sample size, so is not fit for MCMC samples. We should instead pass the bandwidth manually \(n_{eff}^{(-1/(d+4))}\) with \(d=2\); It should capture more modes.</li>
<li>Compute the paper's <i>Mode-coverage</i> metric: when the number of samples falling within the radius \(r\) of a mode center is larger than a number \(N\) when we say the mode is covered;</li>
<li>Use on a "real" problem: CIFAR-100 with Resnet18 for instance;</li>
</ul>
</div>
</div>
</div>
</body>
</html>