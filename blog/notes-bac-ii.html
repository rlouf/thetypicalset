<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-05-12 Thu 10:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Les notes du bac II</title>
<meta name="author" content="Rémi Louf" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../style.css" /><script data-goatcounter="https://thetypicalset.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Les notes du bac II</h1>
<p>
À l'origine de cette note, un <a target='_blank' rel='noopener noreferrer' class='external' href="https://coulmont.com/blog/2014/10/21/les-notes-du-bac/">post de blog</a> de <a target='_blank' rel='noopener noreferrer' class='external' href="https://twitter.com/coulmont">Baptiste Coulmont</a> sur l'évolution des notes du bac dans le temps. Plus particulièrement, cette courbe représentant la distribution de la moyennes des notes obtenues au baccalauréat entre 2006 et 2013:
</p>


<div id="org6b7e9ee" class="figure">
<p><img src="img/notes-bac-ii-repartition-notes-coulmont.png" alt="notes-bac-ii-repartition-notes-coulmont.png" width="100%" />
</p>
</div>

<p>
Cette courbe est très éloignée de la gaussienne attendue. Le but de cet exercice de modélisation est de montrer qu'il est néanmoins possible de reproduire cette courbe <i>en supposant que la distribution des moyennes avant l'intervention du jury est normale.</i>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-style: italic;">"""Load grade distribution from disk"""</span>
<span style="font-weight: bold;">import</span> arviz <span style="font-weight: bold;">as</span> az
<span style="font-weight: bold;">import</span> matplotlib.pyplot <span style="font-weight: bold;">as</span> plt
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> pandas <span style="font-weight: bold;">as</span> pd
<span style="font-weight: bold;">import</span> pymc3 <span style="font-weight: bold;">as</span> pm
<span style="font-weight: bold;">import</span> scipy.stats <span style="font-weight: bold;">as</span> stats
<span style="font-weight: bold;">import</span> scipy.special <span style="font-weight: bold;">as</span> special

<span style="font-weight: bold; font-style: italic;">plt.rcParams</span>[<span style="font-style: italic;">'font.family'</span>] = <span style="font-style: italic;">'serif'</span>

<span style="font-weight: bold; font-style: italic;">notes_df</span> = pd.read_csv(<span style="font-style: italic;">'./data/notes_baccalaureat_general_2016.csv'</span>, names=[<span style="font-style: italic;">'moyenne'</span>, <span style="font-style: italic;">'num_candidats'</span>])[1:]
<span style="font-weight: bold; font-style: italic;">notes_df</span>[<span style="font-style: italic;">'num_candidats'</span>] = pd.to_numeric(notes_df[<span style="font-style: italic;">'num_candidats'</span>])
<span style="font-weight: bold; font-style: italic;">notes_df</span>[<span style="font-style: italic;">'moyenne'</span>] = pd.to_numeric(notes_df[<span style="font-style: italic;">'moyenne'</span>])

<span style="font-weight: bold; font-style: italic;">num_candidats</span> = notes_df[<span style="font-style: italic;">'num_candidats'</span>].values
<span style="font-weight: bold; font-style: italic;">moyenne</span> = notes_df[<span style="font-style: italic;">'moyenne'</span>].values
</pre>
</div>

<p>
Nous n'avons malheureusement à notre disposition que les <a target='_blank' rel='noopener noreferrer' class='external' href="https://archives-statistiques-depp.education.gouv.fr/Default/digital-viewer/c-13341">données concernant la première session 2016</a> (si vous avez accès à plus de données, je vous serais reconnaissant de bien vouloir me <a target='_blank' rel='noopener noreferrer' class='external' href="https://twitter.com/remilouf">contacter</a>) :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span> = plt.subplots()
ax.bar(x=moyenne, height=num_candidats, width=0.1, color=<span style="font-style: italic;">'black'</span>)
ax.set_xlabel(<span style="font-style: italic;">"Moyenne &#224; l'issue de la premi&#232;re session"</span>)
ax.set_ylabel(<span style="font-style: italic;">"Nombre de candidats"</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Remove axis lines.</span>
ax.spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
ax.spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set spine extent.</span>
ax.spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 20)
ax.spines[<span style="font-style: italic;">'left'</span>].set_bounds(0, <span style="font-weight: bold;">max</span>(num_candidats))

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set x ticks</span>
<span style="font-weight: bold; font-style: italic;">x_ticks</span> = [0, 8, 10, 12, 14, 16, 20]
ax.xaxis.set_ticks(x_ticks)

plt.figtext(
    0,
    -.02,
    <span style="font-style: italic;">'auteur: @remilouf\nsource: MESNER-DEPP, R&#233;sultats d&#233;finitifs de la session 2016 du baccalaur&#233;at'</span>,
    fontsize=6
)

<span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"images/notes-bac-distribution-2016.svg"</span>
plt.savefig(fname, bbox_inches=<span style="font-style: italic;">'tight'</span>)
fname
</pre>
</div>


<div id="orgff7060c" class="figure">
<p><img src="img/notes-bac-distribution-2016.svg" alt="notes-bac-distribution-2016.svg" class="org-svg" />
</p>
</div>

<p>
Cette courbe-ci est aussi éloignée d'une simple loi normale, avec des pics autour des notes 8, 10, 12, 14, 16 qui correspondent respectivement à la note minimale pour aller au rattrapage, la note d'admission, les mentions AB, B et TB. Nous allons montrer ici que la courbe s'explique très bien en supposant que la distribution des moyennes est normale et en modélisant l'intervention du jury.
</p>

<div id="outline-container-orgb57d6a2" class="outline-2">
<h2 id="orgb57d6a2">Modèle</h2>
<div class="outline-text-2" id="text-orgb57d6a2">
</div>
<div id="outline-container-orgb9d7304" class="outline-3">
<h3 id="orgb9d7304">Des notes à l'histogramme</h3>
<div class="outline-text-3" id="text-orgb9d7304">
<p>
On note \(\theta_n \in \left[0, 20\right]\) la moyenne brute du candidat \(n\), c'est-à-dire avant l'intervention du jury :
</p>

<div class="org-src-container">
<pre class="src src-latex"><span style="font-weight: bold;">\begin</span>{<span style="font-weight: bold;">equation*</span>}
<span style="font-weight: bold;">\theta</span>_n <span style="font-weight: bold;">\sim</span> <span style="font-weight: bold;">\operatorname</span>{Normal}(<span style="font-weight: bold;">\mu</span>, <span style="font-weight: bold;">\sigma</span>)
<span style="font-weight: bold;">\end</span>{<span style="font-weight: bold;">equation*</span>}
</pre>
</div>

\begin{equation*}
\theta_n \sim \operatorname{Normal}(\mu, \sigma)
\end{equation*}

<p>
\(\mu\) est la "vraie" moyenne des notes du bac, \(\sigma\) sa "vraie" déviation standard. Une inspection rapide du graphe nous permet de définir les priors vaguement informatifs suivants:
</p>

<div class="org-src-container">
<pre class="src src-latex"><span style="font-weight: bold;">\begin</span>{<span style="font-weight: bold;">align*</span>}
  <span style="font-weight: bold;">\displaystyle</span>
  <span style="font-weight: bold;">\mu</span> &amp;<span style="font-weight: bold;">\sim</span> <span style="font-weight: bold;">\operatorname</span>{Normal}(12,2)<span style="font-weight: bold;">\\</span>
  <span style="font-weight: bold;">\sigma</span> &amp;<span style="font-weight: bold;">\sim</span> <span style="font-weight: bold;">\max</span> <span style="font-weight: bold;">\left</span>[0, <span style="font-weight: bold;">\operatorname</span>{Normal}(2.5, 2)<span style="font-weight: bold;">\right</span>]
<span style="font-weight: bold;">\end</span>{<span style="font-weight: bold;">align*</span>}
</pre>
</div>

\begin{align*}
  \displaystyle
  \mu &\sim \operatorname{Normal}(12,2)\\
  \sigma &\sim \max \left[0, \operatorname{Normal}(2.5, 2)\right]
\end{align*}

<p>
Cependant nous ne disposons par des notes individuelles
\(\left\{\theta_n\right\}_{n=1\dots N_{candidats}}\), mais du vecteur des \(N_i\) le
nombre de candidats ayant obtenu la note \(i\). Pour obtenir ce vecteur les notes
sont visiblement arrondies au dixième de point près : nous supposerons qu'une
note entre \(0\) et \(0.5\) sera arrondie à 0, entre \(0.5\) et \(1.5\) à \(1\), etc.
</p>

<p>
Notons \(\mathbf{N} = \left(N_0, \dots, N_{201}\right)\)  le vecteur qui contient le nombre \(N_0\) de notes arrondies à \(0\), &hellip; \(N_{201}\) le nombre de notes arrondies à 20. Nous supposons que ce vecteur est distribué selon une loi multinomiale, où la probabilité de tomber dans la \(i\) -ème catégorie est donnée par l'intégrale de la distribution des \(\theta\) entre \(0.1 * i -0.5\) et \(0.1*i + 0.5\):
</p>

<div class="org-src-container">
<pre class="src src-latex"><span style="font-weight: bold;">\begin</span>{<span style="font-weight: bold;">align*</span>}
<span style="font-weight: bold;">\mathbf</span>{N} &amp;<span style="font-weight: bold;">\sim</span> <span style="font-weight: bold;">\operatorname</span>{Multinomial}(<span style="font-weight: bold;">\mathbf</span>{p}, N_{candidats})<span style="font-weight: bold;">\\</span>
  p_{i} &amp;= <span style="font-weight: bold;">\int</span>_{0.1\,i-0.05}^{0.1\,i + 0.05} P(<span style="font-weight: bold;">\theta</span>_n=<span style="font-weight: bold;">\theta</span>|<span style="font-weight: bold;">\mu</span>,<span style="font-weight: bold;">\sigma</span>) <span style="font-weight: bold;">\mathrm</span>{d}<span style="font-weight: bold;">\theta</span>
<span style="font-weight: bold;">\end</span>{<span style="font-weight: bold;">align*</span>}
</pre>
</div>

\begin{align*}
\mathbf{N} &\sim \operatorname{Multinomial}(\mathbf{p}, N_{candidats})\\
  p_{i} &= \int_{0.1\,i-0.05}^{0.1\,i + 0.05} P(\theta_n=\theta|\mu,\sigma) \mathrm{d}\theta
\end{align*}

<p>
Le modèle est bien moins compliqué que ça en a l'air. On peut l'utiliser pour simuler de fausses données avec le code suivant:
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> scipy.stats <span style="font-weight: bold;">as</span> stats

<span style="font-weight: bold; font-style: italic;">rng</span> = np.random.default_rng()
<span style="font-weight: bold; font-style: italic;">bins</span> = [0] + [0.05 + 0.1 * i <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(200)] + [20]

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">simulate</span>(num_candidats, moyenne=12, sd=2.5):
    <span style="font-weight: bold; font-style: italic;">probs</span> = stats.norm(moyenne, sd).cdf(bins)
    <span style="font-weight: bold; font-style: italic;">probs</span> = [b-a <span style="font-weight: bold;">for</span> a, b <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">zip</span>(probs[:-1], probs[1:])]
    <span style="font-weight: bold; font-style: italic;">hist</span> = rng.multinomial(num_candidats, probs)
    <span style="font-weight: bold;">return</span> hist
</pre>
</div>

<p>
Et l'on obtient la courbe suivante :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">num</span> = simulate(np.<span style="font-weight: bold;">sum</span>(num_candidats), 12.2, 2.9)

<span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span> = plt.subplots()
ax.bar(
    x=moyenne,
    height=num,
    width=0.1,
    label=<span style="font-style: italic;">"Simulation (gaussienne)"</span>,
    color=<span style="font-style: italic;">"lightgray"</span>
)
ax.step(
    x=moyenne,
    y=num_candidats,
    label=<span style="font-style: italic;">"Donn&#233;es"</span>,
    color=<span style="font-style: italic;">'black'</span>
)
ax.set_xlabel(<span style="font-style: italic;">"Moyenne &#224; l'issue de la premi&#232;re session"</span>)
ax.set_ylabel(<span style="font-style: italic;">"Nombre de candidats"</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Remove axis lines.</span>
ax.spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
ax.spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set spine extent.</span>
ax.spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 20)
ax.spines[<span style="font-style: italic;">'left'</span>].set_bounds(0, <span style="font-weight: bold;">max</span>(num_candidats))

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set x ticks</span>
<span style="font-weight: bold; font-style: italic;">x_ticks</span> = [0, 8, 10, 12, 14, 16, 20]
ax.xaxis.set_ticks(x_ticks)

plt.legend(frameon=<span style="font-weight: bold; text-decoration: underline;">False</span>)

plt.figtext(
    0,
    -.02,
    <span style="font-style: italic;">'auteur: @remilouf\nsource: MESNER-DEPP, R&#233;sultats d&#233;finitifs de la session 2016 du baccalaur&#233;at'</span>,
    fontsize=6
)

<span style="font-weight: bold; font-style: italic;">fname</span> = <span style="font-style: italic;">"./images/bac-premiere-normal_histogram.svg"</span>
plt.savefig(fname, bbox_inches=<span style="font-style: italic;">"tight"</span>)
fname
</pre>
</div>


<div id="org210b0d2" class="figure">
<p><img src="img/bac-premiere-normal_histogram.svg" alt="bac-premiere-normal_histogram.svg" class="org-svg" />
</p>
</div>

<p>
Cette simple gaussienne n'est pas une mauvaise approximation à la courbe de départ. Reste maintenant à comprendre d'où viennent les creux et les pics dans les données.
</p>
</div>
</div>

<div id="outline-container-org488b977" class="outline-3">
<h3 id="org488b977">Intervention du jury</h3>
<div class="outline-text-3" id="text-org488b977">
<p>
On observe un évident effet d'arrondi autour des notes:
</p>
<ul class="org-ul">
<li>8 qui détermine si l'élève est admis au rattrapage;</li>
<li>10 qui détermine si l'élève est admis;</li>
<li>12, 14, 16 qui déterminent les mentions AB, B, TB</li>
</ul>

<p>
On note \(\Omega = \left\{8, 10, 12, 14, 16\right\}\) l'ensemble des notes pour
lesquelles on s'attend à observer un effet de seuil et \(\tilde{\theta}_n\) la
note du candidat \(n\) après intervention du jury. On suppose que la probabilité que le jury intervienne, i.e. que \(\tilde{\theta}_n \in \Omega\) décroit de façon exponentielle en fonction de la distance entre \(\bar{\theta}_n\) et \(\omega_{f(n)}\) où \(f(n)\) est l'indice de la note seuil correspondante à la note de l'élève \(n\) dans \(\Omega\) :
</p>

<div class="org-src-container">
<pre class="src src-latex"><span style="font-weight: bold;">\begin</span>{<span style="font-weight: bold;">align*</span>}
  <span style="font-weight: bold;">\mathbf</span>{<span style="font-weight: bold;">\alpha</span>} &amp;<span style="font-weight: bold;">\sim</span> <span style="font-weight: bold;">\operatorname</span>{Exponential}(5.)<span style="font-weight: bold;">\\</span>
  P(<span style="font-weight: bold;">\tilde</span>{<span style="font-weight: bold;">\theta</span>}_{n} = <span style="font-weight: bold;">\omega</span>_{f(n)}) &amp;= <span style="font-weight: bold;">\exp</span> <span style="font-weight: bold;">\left</span>(-<span style="font-weight: bold;">\alpha</span>_{f(n)} (<span style="font-weight: bold;">\omega</span>_{f(n)} - <span style="font-weight: bold;">\bar</span>{<span style="font-weight: bold;">\theta</span>}_{n})<span style="font-weight: bold;">\right</span>)
<span style="font-weight: bold;">\end</span>{<span style="font-weight: bold;">align*</span>}
</pre>
</div>

\begin{align*}
  \mathbf{\alpha} &\sim \operatorname{Exponential}(5.)\\
  P(\tilde{\theta}_{n} = \omega_{f(n)}) &= \exp \left(-\alpha_{f(n)} (\omega_{f(n)} - \bar{\theta}_{n})\right)
\end{align*}


<p>
Comme précédemment avec le modèle gaussien il est possible de générer des données synthétiques à partir de ce modèle:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> scipy.stats <span style="font-weight: bold;">as</span> stats
<span style="font-weight: bold; font-style: italic;">moyennes</span> = notes_df.moyenne.values

<span style="font-weight: bold; font-style: italic;">rng</span> = np.random.default_rng()
<span style="font-weight: bold; font-style: italic;">seuils</span> = np.array([8, 10, 12, 14, 16, 1000])
<span style="font-weight: bold; font-style: italic;">bins</span> = [0] + [0.05 + 0.1 * i <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(200)] + [20]

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">simulate_all</span>(mu, sd, alpha):
    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Les notes sont distribu&#233;es selon une gaussienne puis arrondies et regroup&#233;es</span>
    <span style="font-weight: bold; font-style: italic;">hist_probs</span> = stats.norm(mu, sd).cdf(bins)
    <span style="font-weight: bold; font-style: italic;">hist_probs</span> = np.array([b-a <span style="font-weight: bold;">for</span> a, b <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">zip</span>(hist_probs[:-1], hist_probs[1:])])
    <span style="font-weight: bold; font-style: italic;">hist</span> = rng.multinomial(np.<span style="font-weight: bold;">sum</span>(num_candidats), hist_probs)

    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Le jury accorde le rattrapage, l'admission ou la mention</span>
    <span style="font-weight: bold; font-style: italic;">idx</span> = np.searchsorted(seuils, moyennes)
    <span style="font-weight: bold; font-style: italic;">delta</span> = seuils[idx] - moyennes
    <span style="font-weight: bold; font-style: italic;">p_repechage</span> = np.exp(- delta * alpha[idx])
    <span style="font-weight: bold; font-style: italic;">repeches</span> = rng.binomial(hist, p_repechage)

    <span style="font-weight: bold; font-style: italic;">hist</span> -= repeches
    <span style="font-weight: bold;">for</span> i, seuil <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">enumerate</span>(seuils):
        <span style="font-weight: bold; font-style: italic;">hist</span>[moyennes == seuil] += np.<span style="font-weight: bold;">sum</span>(repeches[idx==i])
    <span style="font-weight: bold;">return</span> hist
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">num</span> = simulate_all(12.2, 2.9, 5. * np.ones(6))

<span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span> = plt.subplots()
ax.bar(
    x=moyenne,
    height=num,
    width=0.1,
    label=<span style="font-style: italic;">"Simulation (gaussienne)"</span>,
    color=<span style="font-style: italic;">"lightgray"</span>
)
ax.step(
    x=moyenne,
    y=num_candidats,
    label=<span style="font-style: italic;">"Donn&#233;es"</span>,
    color=<span style="font-style: italic;">'black'</span>
)
ax.set_xlabel(<span style="font-style: italic;">"Moyenne &#224; l'issue de la premi&#232;re session"</span>)
ax.set_ylabel(<span style="font-style: italic;">"Nombre de candidats"</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Remove axis lines.</span>
ax.spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
ax.spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set spine extent.</span>
ax.spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 20)
ax.spines[<span style="font-style: italic;">'left'</span>].set_bounds(0, <span style="font-weight: bold;">max</span>(num_candidats))

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set x ticks</span>
<span style="font-weight: bold; font-style: italic;">x_ticks</span> = [0, 8, 10, 12, 14, 16, 20]
ax.xaxis.set_ticks(x_ticks)

plt.legend(frameon=<span style="font-weight: bold; text-decoration: underline;">False</span>)

plt.figtext(
    0,
    -.02,
    <span style="font-style: italic;">'auteur: @remilouf\nsource: MESNER-DEPP, R&#233;sultats d&#233;finitifs de la session 2016 du baccalaur&#233;at'</span>,
    fontsize=6
)

<span style="font-weight: bold; font-style: italic;">fname</span> = <span style="font-style: italic;">"./images/bac-premiere-all_histogram.png"</span>
plt.savefig(fname, bbox_inches=<span style="font-style: italic;">"tight"</span>)
fname
</pre>
</div>

<div id="orgddc6a66" class="figure">
<p><img src="img/bac-premiere-all_histogram.png" alt="bac-premiere-all_histogram.png" />
</p>
</div>

<p>
Pas mal!
</p>
</div>
</div>

<div id="outline-container-org26bd16d" class="outline-3">
<h3 id="org26bd16d">Inférence</h3>
<div class="outline-text-3" id="text-org26bd16d">
<p>
Maintenant que nous avons un modèle capable de produire des données synthétiques proches des donnée observées nous pouvons passer à l'étape suivante: utiliser le modèle avec les données pour calculer la distribution postérieur des paramètres \(\mu\), \(\sigma\) et \(\mathbf{\alpha}\). À cause de la nature de l'intervention du jury il est compliqué d'écrire une fonction de vraissemblance pour ce modèle. Nous devons donc utiliser l'<a href="../20211203143110-approximate_bayesian_computation.html#ID-0eefdc2c-544a-47b7-8e3b-05a3c196d2b3">Approximate Bayesian Computation</a>. Le modèle s'écrit avec PyMC:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">with</span> pm.Model() <span style="font-weight: bold;">as</span> model:
    <span style="font-weight: bold; font-style: italic;">mu</span> = pm.Normal(<span style="font-style: italic;">"mu"</span>, 12, 2)
    <span style="font-weight: bold; font-style: italic;">sd</span> = pm.TruncatedNormal(<span style="font-style: italic;">"sd"</span>, 2, 1, lower=0.1)
    <span style="font-weight: bold; font-style: italic;">alpha</span> = pm.Exponential(<span style="font-style: italic;">"alpha"</span>, 5.0, shape=(6,))
    <span style="font-weight: bold; font-style: italic;">s</span> = pm.Simulator(
        <span style="font-style: italic;">"s"</span>,
        simulate_all,
        params=(mu, sd, alpha),
        epsilon=1000,
        observed=num_candidats
    )
</pre>
</div>

<p>
L'inférence se déroule sans problème avec \(\epsilon = 1000\) :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">with</span> model:
    <span style="font-weight: bold; font-style: italic;">trace</span> = pm.sample_smc(
        kernel=<span style="font-style: italic;">'ABC'</span>,
        chains=1,
        parallel=<span style="font-weight: bold; text-decoration: underline;">True</span>,
        save_sim_data=<span style="font-weight: bold; text-decoration: underline;">True</span>
        )
</pre>
</div>

<p>
Regardons la trace et la distribution postérieure des différentes variables pour vérifier que tout s'est déroulé sans problème :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span>  = plt.subplots()
az.plot_trace(trace[0]);
<span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"images/notes-bac-premiere-trace.svg"</span>
plt.tight_layout()
plt.savefig(fname)
fname
</pre>
</div>


<div id="org81a4759" class="figure">
<p><img src="img/notes-bac-premiere-trace.svg" alt="notes-bac-premiere-trace.svg" class="org-svg" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbb1f363" class="outline-2">
<h2 id="orgbb1f363">Résultats</h2>
<div class="outline-text-2" id="text-orgbb1f363">
<p>
Avant de se lancer dans des inteprétations vérifions que la distribution postérieure prédictive de notre modèle reproduit les données de façon satisfaisante. Chaque courbe bleue correspond à une simulation :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span> = plt.subplots(figsize=(10,6))
ax.step(moyennes, notes_df.num_candidats, ls=<span style="font-style: italic;">'--'</span>, color=<span style="font-style: italic;">'grey'</span>, label=<span style="font-style: italic;">'Donn&#233;es'</span>)

<span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(1000):
    ax.step(moyennes, trace[1][<span style="font-style: italic;">'s'</span>][0][i], color=<span style="font-style: italic;">'b'</span>, alpha=0.005)
ax.step(moyennes, trace[1][<span style="font-style: italic;">'s'</span>][0][i], color=<span style="font-style: italic;">'b'</span>, alpha=0.1, label=<span style="font-style: italic;">'Pr&#233;dictions du mod&#232;le'</span>)

ax.set_xlabel(<span style="font-style: italic;">"Moyenne &#224; l'issue de la premi&#232;re session"</span>)
ax.set_ylabel(<span style="font-style: italic;">"Nombre de candidats"</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Remove axis lines.</span>
ax.spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
ax.spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set spine extent.</span>
ax.spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 20)
ax.spines[<span style="font-style: italic;">'left'</span>].set_bounds(0, 17500)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set x ticks</span>
<span style="font-weight: bold; font-style: italic;">x_ticks</span> = [0, 8, 10, 12, 14, 16, 20]
ax.xaxis.set_ticks(x_ticks)

plt.legend(frameon=<span style="font-weight: bold; text-decoration: underline;">False</span>)

plt.figtext(
    0,
    -.02,
    <span style="font-style: italic;">'auteur: @remilouf\nsource: MESNER-DEPP, R&#233;sultats d&#233;finitifs de la session 2016 du baccalaur&#233;at'</span>,
    fontsize=6
)

<span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"images/notes-bac-premiere-posterior-predictive.svg"</span>
plt.tight_layout()
plt.savefig(fname, bbox_inches=<span style="font-style: italic;">'tight'</span>)
fname
</pre>
</div>


<div id="org9981907" class="figure">
<p><img src="img/notes-bac-premiere-posterior-predictive.svg" alt="notes-bac-premiere-posterior-predictive.svg" class="org-svg" />
</p>
</div>

<p>
Le modèle est plutôt bon, mais avec quelques améliorations possibles:
</p>
<ul class="org-ul">
<li>Le nombre d'élèves repêchés pour la seconde session est surestimé;</li>
<li>Le nombre d'élève ayant obtenu la note 20 est surestimé. Ceci à cause de l'utilisation de la loi normale pour modéliser la distribution de départ et non une loi définie sur un intervalle comme la loi Beta.</li>
<li>Les demi-points sont sur-représentés, sûrement un artefact du fait que les copies sont notées à 0.5 point près (à confirmer)</li>
</ul>

<p>
On peut s'amuser à tracer la distribution de la moyenne des notes avant intervention du jury, et la courbe correspondant à l'intervention du jury de sorte à ce qu'en sommant les deux courbes on retrouve les données :
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">axes</span> = plt.subplots(nrows=2, figsize=(12,8))

<span style="font-weight: bold; font-style: italic;">mu</span> = trace[0][<span style="font-style: italic;">'mu'</span>]
<span style="font-weight: bold; font-style: italic;">sd</span> = trace[0][<span style="font-style: italic;">'sd'</span>]
<span style="font-weight: bold; font-style: italic;">alpha</span> = trace[0][<span style="font-style: italic;">'alpha'</span>]
<span style="font-weight: bold; font-style: italic;">seuils</span> = np.array([8, 10, 12, 14, 16, 1000])
<span style="font-weight: bold;">for</span> a, m, s <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">zip</span>(alpha, mu, sd):
    <span style="font-weight: bold; font-style: italic;">rng</span> = np.random.default_rng()
    <span style="font-weight: bold; font-style: italic;">bins</span> = [0] + [0.05 + 0.1 * i <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(200)] + [20]
    <span style="font-weight: bold; font-style: italic;">hist_probs</span> = stats.norm(m, s).cdf(bins)
    <span style="font-weight: bold; font-style: italic;">hist_probs</span> = np.array([b-a <span style="font-weight: bold;">for</span> a, b <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">zip</span>(hist_probs[:-1], hist_probs[1:])])
    <span style="font-weight: bold; font-style: italic;">hist</span> = rng.multinomial(np.<span style="font-weight: bold;">sum</span>(num_candidats), hist_probs)

    <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Le jury accorde le rattrapage, l'admission ou la mention</span>
    <span style="font-weight: bold; font-style: italic;">idx</span> = np.searchsorted(seuils, moyennes)
    <span style="font-weight: bold; font-style: italic;">delta</span> = seuils[idx] - moyennes
    <span style="font-weight: bold; font-style: italic;">p_repechage</span> = np.exp(- delta * a[idx])
    <span style="font-weight: bold; font-style: italic;">repeches</span> = rng.binomial(hist, p_repechage)

    <span style="font-weight: bold; font-style: italic;">repechages</span> = np.zeros_like(hist)
    <span style="font-weight: bold; font-style: italic;">repechages</span> -= repeches
    <span style="font-weight: bold;">for</span> i, seuil <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">enumerate</span>(seuils):
        <span style="font-weight: bold; font-style: italic;">repechages</span>[moyenne==seuil] = np.<span style="font-weight: bold;">sum</span>(repeches[idx==i])

    axes[0].step(moyenne, hist, alpha=0.006, color=<span style="font-style: italic;">'b'</span>);
    axes[1].step(moyenne, repechages, alpha=0.006, color=<span style="font-style: italic;">'b'</span>);


axes[0].set_title(<span style="font-style: italic;">"R&#233;partition avant intervention du jury"</span>, fontweight=<span style="font-style: italic;">'bold'</span>)
axes[1].set_title(<span style="font-style: italic;">"Intervention du jury"</span>, fontweight=<span style="font-style: italic;">'bold'</span>)

axes[0].set_ylabel(<span style="font-style: italic;">"Nombre de candidats (pre-intervention)"</span>)
axes[1].set_xlabel(<span style="font-style: italic;">"Moyenne &#224; l'issue de la premi&#232;re session"</span>)
axes[1].set_ylabel(<span style="font-style: italic;">"Nombre de candidats (alg&#233;brique)"</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Remove axis lines.</span>
axes[0].spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
axes[0].spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
axes[1].spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
axes[1].spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set spine extent.</span>
axes[0].spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 20)
axes[0].spines[<span style="font-style: italic;">'left'</span>].set_bounds(0, 6000)
axes[1].spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 20)
axes[1].spines[<span style="font-style: italic;">'left'</span>].set_bounds(-5000, 15000)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set x ticks</span>
<span style="font-weight: bold; font-style: italic;">x_ticks</span> = [0, 8, 10, 12, 14, 16, 20]
axes[0].xaxis.set_ticks(x_ticks)
axes[1].xaxis.set_ticks(x_ticks)

plt.legend(frameon=<span style="font-weight: bold; text-decoration: underline;">False</span>)

plt.figtext(
    0,
    -.02,
    <span style="font-style: italic;">'auteur: @remilouf\nsource: MESNER-DEPP, R&#233;sultats d&#233;finitifs de la session 2016 du baccalaur&#233;at'</span>,
    fontsize=10
)

<span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"images/notes-baccalaureat-gaussian-posterior.svg"</span>
plt.tight_layout()
plt.savefig(fname, bbox_inches=<span style="font-style: italic;">'tight'</span>)
fname
</pre>
</div>


<div id="org113c7a8" class="figure">
<p><img src="img/notes-baccalaureat-gaussian-posterior.svg" alt="notes-baccalaureat-gaussian-posterior.svg" class="org-svg" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">alpha</span> = trace[0][<span style="font-style: italic;">'alpha'</span>]

<span style="font-weight: bold; font-style: italic;">seuils</span> = [6, 8, 10, 12, 14, 16]
<span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">axes</span> = plt.subplots(ncols=2, nrows=3)
<span style="font-weight: bold; font-style: italic;">axes</span> = axes.flatten()
<span style="font-weight: bold;">for</span> i, (s0, s1) <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">enumerate</span>(<span style="font-weight: bold;">zip</span>(seuils[:-1], seuils[1:])):
    <span style="font-weight: bold; font-style: italic;">notes</span> = np.linspace(s0, s1, 100)
    <span style="font-weight: bold; font-style: italic;">delta</span> = s1 - notes
    <span style="font-weight: bold; font-style: italic;">p</span> = np.exp(-np.outer(alpha[:, i], delta))
    <span style="font-weight: bold;">for</span> post_idx <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(10):
        axes[i].plot(notes, p[post_idx,:], color=<span style="font-style: italic;">'b'</span>, alpha=.1)

<span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"images/notes-baccalaureat-proba-repechage.svg"</span>
plt.savefig(fname)
fname
</pre>
</div>


<div id="org573bb2f" class="figure">
<p><img src="img/notes-baccalaureat-proba-repechage.svg" alt="notes-baccalaureat-proba-repechage.svg" class="org-svg" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">import</span> bisect

<span style="font-weight: bold; font-style: italic;">seuils</span> = [6, 8, 10, 12, 14, 16]
<span style="font-weight: bold; font-style: italic;">labels</span> = [<span style="font-style: italic;">"Rattrapage"</span>, <span style="font-style: italic;">"Admis"</span>, <span style="font-style: italic;">"AB"</span>, <span style="font-style: italic;">"B"</span>, <span style="font-style: italic;">"TB"</span>]
<span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span> = plt.subplots()
<span style="font-weight: bold;">for</span> i, (s0, s1) <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">enumerate</span>(<span style="font-weight: bold;">zip</span>(seuils[:-1], seuils[1:])):
    <span style="font-weight: bold; font-style: italic;">notes</span> = np.linspace(s0, s1, 200)
    <span style="font-weight: bold; font-style: italic;">delta</span> = s1 - notes
    <span style="font-weight: bold; font-style: italic;">p</span> = np.mean(np.exp(-np.outer(alpha[:, i], delta)), axis=0)
    <span style="font-weight: bold; font-style: italic;">n</span> = bisect.bisect_left(delta[::-1], 1.)
    <span style="font-weight: bold;">print</span>(f<span style="font-style: italic;">"{labels[i]}: {p[n]*100:.0f}%"</span>)
</pre>
</div>

<p>
La probabilité que le jury intervienne en faveur d'un candidat n'est clairement pas la même en fonction du seuil qui est concerné:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">alpha</span> = trace[0][<span style="font-style: italic;">'alpha'</span>]

<span style="font-weight: bold; font-style: italic;">seuils</span> = [6, 8, 10, 12, 14, 16]
<span style="font-weight: bold; font-style: italic;">labels</span> = [<span style="font-style: italic;">"Rattrapage"</span>, <span style="font-style: italic;">"Admis"</span>, <span style="font-style: italic;">"AB"</span>, <span style="font-style: italic;">"B"</span>, <span style="font-style: italic;">"TB"</span>]
<span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">ax</span> = plt.subplots()
<span style="font-weight: bold;">for</span> i, (s0, s1) <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">enumerate</span>(<span style="font-weight: bold;">zip</span>(seuils[:-1], seuils[1:])):
    <span style="font-weight: bold; font-style: italic;">notes</span> = np.linspace(s0, s1, 100)
    <span style="font-weight: bold; font-style: italic;">delta</span> = s1 - notes
    <span style="font-weight: bold; font-style: italic;">p</span> = np.mean(np.exp(-np.outer(alpha[:, i], delta)), axis=0)
    ax.plot(delta, p, label=f<span style="font-style: italic;">"{s1} ({labels[i]})"</span>)

ax.axvline(x=1., ls=<span style="font-style: italic;">'--'</span>, lw=0.5, color=<span style="font-style: italic;">'black'</span>)

ax.set_xlabel(<span style="font-style: italic;">"Distance &#224; la note seuil"</span>)
ax.set_ylabel(<span style="font-style: italic;">"Probabilit&#233; de voir sa moyenne arrondie"</span>)
ax.set_title(<span style="font-style: italic;">"Probabilit&#233; d'intervention du jury en fonction de la distance &#224; la note seuil"</span>, fontweight=<span style="font-style: italic;">'bold'</span>)

plt.legend(frameon=<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Remove axis lines.</span>
ax.spines[<span style="font-style: italic;">'top'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)
ax.spines[<span style="font-style: italic;">'right'</span>].set_visible(<span style="font-weight: bold; text-decoration: underline;">False</span>)

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Set spine extent.</span>
ax.spines[<span style="font-style: italic;">'bottom'</span>].set_bounds(0, 2)
ax.spines[<span style="font-style: italic;">'left'</span>].set_bounds(0, 1)

plt.legend(frameon=<span style="font-weight: bold; text-decoration: underline;">False</span>)

plt.figtext(
    0,
    -.02,
    <span style="font-style: italic;">'auteur: @remilouf\nsource: MESNER-DEPP, R&#233;sultats d&#233;finitifs de la session 2016 du baccalaur&#233;at'</span>,
    fontsize=6
)

<span style="font-weight: bold; font-style: italic;">fname</span>=<span style="font-style: italic;">"images/notes-baccalaureat-proba-repechage_avg.svg"</span>
plt.savefig(fname, bbox_inches=<span style="font-style: italic;">'tight'</span>)
fname
</pre>
</div>


<div id="org9c4d4f1" class="figure">
<p><img src="img/notes-baccalaureat-proba-repechage_avg.svg" alt="notes-baccalaureat-proba-repechage_avg.svg" class="org-svg" />
</p>
</div>

<p>
Plus précisément on peut regarder la probabilité d'intervention lorsque l'on est à un point du seuil. Avec une moyenne de :
</p>
<ul class="org-ul">
<li>7 un candidat a 13% de chance d'être au rattrapage;</li>
<li>9 un candidat a 7% de chance d'être admis;</li>
<li>11 un candidat a 2% de chance d'avoir la mention Bien;</li>
<li>13 un candidat a 2% de chance d'avoir la mention Assez Bien;</li>
<li>15 un candidat a 6% de chance d'avoir la mention Très Bien;</li>
</ul>


<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold; font-style: italic;">fig</span>, <span style="font-weight: bold; font-style: italic;">axes</span> = plt.subplots(nrows=2)

<span style="font-weight: bold; font-style: italic;">repeches_samples</span> = []

<span style="font-weight: bold; font-style: italic;">mu</span> = trace[0][<span style="font-style: italic;">'mu'</span>]
<span style="font-weight: bold; font-style: italic;">sd</span> = trace[0][<span style="font-style: italic;">'sd'</span>]
<span style="font-weight: bold; font-style: italic;">alpha</span> = trace[0][<span style="font-style: italic;">'alpha'</span>]
<span style="font-weight: bold; font-style: italic;">seuils</span> = np.array([8, 10, 12, 14, 16, 1000])
<span style="font-weight: bold;">for</span> a, m, s <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">zip</span>(alpha, mu, sd):
    <span style="font-weight: bold; font-style: italic;">rng</span> = np.random.default_rng()
    <span style="font-weight: bold; font-style: italic;">bins</span> = [0] + [0.05 + 0.1 * i <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(200)] + [20]
    <span style="font-weight: bold; font-style: italic;">hist_probs</span> = stats.norm(m, s).cdf(bins)
    <span style="font-weight: bold; font-style: italic;">hist_probs</span> = np.array([b-a <span style="font-weight: bold;">for</span> a, b <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">zip</span>(hist_probs[:-1], hist_probs[1:])])
    <span style="font-weight: bold; font-style: italic;">notes</span> = rng.multinomial(np.<span style="font-weight: bold;">sum</span>(num_candidats), hist_probs)

    <span style="font-weight: bold; font-style: italic;">idx</span> = np.searchsorted(seuils, moyenne)
    <span style="font-weight: bold; font-style: italic;">delta</span> = seuils[idx] - moyenne
    <span style="font-weight: bold; font-style: italic;">p_repechage</span> = np.exp(-delta * a[idx])
    <span style="font-weight: bold; font-style: italic;">repeches</span> = rng.binomial(notes, p_repechage)

    <span style="font-weight: bold; font-style: italic;">a</span> = np.zeros_like(seuils)
    <span style="font-weight: bold;">for</span> i, seuil <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">enumerate</span>(seuils):
        <span style="font-weight: bold; font-style: italic;">a</span>[i] = np.<span style="font-weight: bold;">sum</span>(repeches[idx==i])

    repeches_samples.append(a)

<span style="font-weight: bold; font-style: italic;">tot</span> = np.mean(np.vstack(repeches_samples), axis=0)
<span style="font-weight: bold; font-style: italic;">s</span> = np.percentile(np.vstack(repeches_samples), [5, 95], axis=0).T
<span style="font-weight: bold;">print</span>(tot[0] / np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 8]))
<span style="font-weight: bold;">print</span>(s[0] / np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 8]))
<span style="font-weight: bold;">print</span>(tot[1] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 8])))
<span style="font-weight: bold;">print</span>(s[1] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 8])))
<span style="font-weight: bold;">print</span>(tot[2] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])))
<span style="font-weight: bold;">print</span>(s[2] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])))
<span style="font-weight: bold;">print</span>(tot[3] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])))
<span style="font-weight: bold;">print</span>(s[3] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])))
<span style="font-weight: bold;">print</span>(tot[4] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 16])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])))
<span style="font-weight: bold;">print</span>(s[4] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 16])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])))

<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">"proportion of repeches in all mentions"</span>)
<span style="font-weight: bold;">print</span>(tot[0] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==8]) +np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 8])))
<span style="font-weight: bold;">print</span>(s[0] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==8]) +np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 8])))
<span style="font-weight: bold;">print</span>(tot[1] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==10]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])))
<span style="font-weight: bold;">print</span>(s[1] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==10]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 10])))
<span style="font-weight: bold;">print</span>(tot[2] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==12]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])))
<span style="font-weight: bold;">print</span>(s[2] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==12]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 12])))
<span style="font-weight: bold;">print</span>(tot[3] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==14]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 16])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])))
<span style="font-weight: bold;">print</span>(s[3] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==14]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 16])-np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &lt; 14])))
<span style="font-weight: bold;">print</span>(tot[4] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==16]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &gt; 16])))
<span style="font-weight: bold;">print</span>(s[4] / (np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne==16]) + np.<span style="font-weight: bold;">sum</span>(num_candidats[moyenne &gt; 16])))

<span style="font-weight: bold;">print</span>(<span style="font-style: italic;">"num concerness"</span>)
<span style="font-weight: bold;">print</span>(np.<span style="font-weight: bold;">sum</span>(tot[:5])/np.<span style="font-weight: bold;">sum</span>(num_candidats))
</pre>
</div>

<pre class="example">
None
</pre>


<p>
Au coeur de la controverse de départ, le lieu commun des discussion autour du baccalauréat: on "donne le bac à tout le monde (de nos jours)". Sans vouloir pour autant tirer de grandes leçon sur l'état de l'Education Nationale et le déclin de la civilisation, nous pouvons estimer le % de candidats qui ont été admis à la seconde session/admis/ont obtenu une mention grâce à l'intervention du jury parmis ceux qui ne l'étaient pas:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Seuil</th>
<th scope="col" class="org-left">% éligibles après intervention du jury</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Rattrapage</td>
<td class="org-left">41%  [33%-49%]</td>
</tr>

<tr>
<td class="org-left">Admis</td>
<td class="org-left">29%  [25%-32%]</td>
</tr>

<tr>
<td class="org-left">Mention AB</td>
<td class="org-left">16%  [14%-17%]</td>
</tr>

<tr>
<td class="org-left">Mention B</td>
<td class="org-left">15%  [14%-17%]</td>
</tr>

<tr>
<td class="org-left">Mention TB</td>
<td class="org-left">15%  [13%-17%]</td>
</tr>
</tbody>
</table>

<p>
Le tableau se lit comme suit: <i>"Entre 33% et 49% des candidats qui avaient une moyenne inférieure à 8 ont été admis à la seconde session."</i> ou <i>"Entre 14%  et 17% des élèves qui ont eu une moyenne inférieure à 12 ont eu une une mention AB."</i>
</p>

<p>
Maintenant une question légèrement différente: parmis les candidats ayant été admis (ont obtenu une mention), quel % l'a été (l'a obtenue) grâce à l'intervention du jury ?
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Seuil</th>
<th scope="col" class="org-left">% obtenu grâce à l'intervention du jury</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Rattrapage</td>
<td class="org-left">13% [10%-15%]</td>
</tr>

<tr>
<td class="org-left">Admis</td>
<td class="org-left">13% [11%-14%]</td>
</tr>

<tr>
<td class="org-left">Mention AB</td>
<td class="org-left">14% [12%-15%]</td>
</tr>

<tr>
<td class="org-left">Mention B</td>
<td class="org-left">18% [16%-19%]</td>
</tr>

<tr>
<td class="org-left">Mention TB</td>
<td class="org-left">20% [17%-23%]</td>
</tr>
</tbody>
</table>

<p>
Le tableau se lit comme suit: "Entre 17% et 23% des candidats ayant obtenus une mention TB se la sont vu attribuer grâce à l'intervention du jury."
</p>
</div>
</div>


<div id="outline-container-org0ce38fb" class="outline-2">
<h2 id="org0ce38fb">Conclusion</h2>
<div class="outline-text-2" id="text-org0ce38fb">
<p>
Pas besoin d'invoquer une version farfelu du théorème de la limite centrale pour justifier la forme de la courbe de départ, elle s'explique en effet très bien par l'intervention du jury sur une distribution qui suit une loi normale. Je suis finalement assez satisfait du modèle (même si quelques petites chose peuvent être améliorées, cf plus haut), et il ne serait pas difficile de le modifier pour modéliser la toute première courbe tirée de l'article de Baptiste Coulmont.
</p>

<p>
Les principaux enseignements, selon moi est que l'intervention du jury est non-négligeable: <i>16% des gens ayant eu une mention, ayant été admis sans mention ou ayant été admis à la seconde session le doivent à l'intervention du jury (20% des mentions TB)</i>. Nous avons également vu que le jury est plus enclin à "aider" les notes inférieures à 8 : 41% des candidats n'étant a priori pas éligibles à la seconde session l'ont été.
</p>

<p>
Je suis statisticien, non sociologue, et je laisse donc ces chiffres à qui veut bien les interpréter. Il serait intéressant de faire le même exercice sur les notes finales, et sur plusieurs années: si vous avez les données et souhaitez collaborer ou tout simplement me les envoyer vous pouvez me contacter par mail ou sur twitter.
</p>
</div>
</div>

<div id="outline-container-org2f00666" class="outline-2">
<h2 id="org2f00666">La suite</h2>
<div class="outline-text-2" id="text-org2f00666">
<p>
<a target='_blank' rel='noopener noreferrer' class='external' href="https://twitter.com/knhede">Kevin Hédé</a> m'a envoyé un lien vers ces trois jeux de données:
</p>
<ul class="org-ul">
<li><a target='_blank' rel='noopener noreferrer' class='external' href="https://archives-statistiques-depp.education.gouv.fr/Default/doc/SYRACUSE/49922/distribution-des-candidats-au-baccalaureat-selon-la-filiere-la-serie-et-la-moyenne-generale-session-">Distribution selon la moyenne, 2018 &amp; 2020</a></li>
<li><a target='_blank' rel='noopener noreferrer' class='external' href="https://archives-statistiques-depp.education.gouv.fr/Default/doc/SYRACUSE/48565/distribution-des-candidats-au-baccalaureat-selon-la-filiere-la-serie-et-la-moyenne-generale-session-">Distrbution selon la moyenne, 2019</a></li>
</ul>

<p>
Remarques:
</p>
<ul class="org-ul">
<li>Les notes <i>avant</i> intervention du jury ne sont <b>pas</b> redressées pour suivre une loi normale; (<a target='_blank' rel='noopener noreferrer' class='external' href="https://twitter.com/knhede">Kevin Hédé</a>)</li>
<li>En 2016 points donnés par la modification de la note d'une matière. A partir de 2021: attribution de points du jury (<a target='_blank' rel='noopener noreferrer' class='external' href="https://twitter.com/PVSM_SES">@PVSM<sub>SES</sub></a>)</li>
</ul>
</div>
</div>


<div id="outline-container-org7288034" class="outline-2">
<h2 id="org7288034"><span class="todo TODO">TODO</span> Figure out what the max grade is. 21?</h2>
</div>
<div id="outline-container-org45cab71" class="outline-2">
<h2 id="org45cab71"><span class="todo TODO">TODO</span> Seconde session 2018, 2019, 2020</h2>
</div>

<div id="outline-container-org8ba1401" class="outline-2">
<h2 id="org8ba1401">Links to this note</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-01 Tue 00:00</p>
<p class="author">Author: Rémi Louf</p>
<p class="email">Email: <a href="mailto:remi@thetypicalset.com">remi@thetypicalset.com</a></p>
<p class="date">Created: 2022-05-12 Thu 10:21</p>
</div>
</body>
</html>
