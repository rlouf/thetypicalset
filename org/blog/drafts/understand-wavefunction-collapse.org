#+TITLE: MiniKanren and WaveFunction Collapse I - The Even Simpler Tiled Model
#+PROPERTY: header-args :eval never-export

#+begin_comment
The original idea was to explore MarkovJunior which uses Markov algorithms to generate images. /MarkovJunior/ is about rewrite rules; it has a set of possible rewrites that it applies recursively, selecting one of the possible rewrites at random at each step. The algorithm stops when no rewrite can be performed anymore. Here we suggest to re-express MarkovJunior using miniKanren, and probably e-graphs (for rewrite saturation at each step)

Markov Junior says how the image should be modified = term rewriting.

What I do not know about yet is how to choose the final solution, but I'll figure it out? Also how does kanren work with an egraph and augments one? all that is v interesting and probably leads me to

One thing is that is purely search and
#+end_comment

Image generation does lend itself quite naturally to /declarative programming/. In the end we are not so interested in /how/ the image was generated as /what/ it looks like. What it looks like is determined by how neighbouring pixels /relate/ to each other.

Methods like Wavefunction collapse will start from example tiles, which describe /how/ we want the picture to look like, and try to extrapolate them to a larger picture. Wavefunction collapse is about finding the pixel arrangement that satistifies some local constraints as defined by the original tiles. But quite in a similar fashion to [[file:~/projects/thetypicalset/org/blog/solve-sudokus-kanren.org][Peter Norvig's solution to the sudoku]], much of the thought is given to the search strategy.


[[https://robertheaton.com/2018/12/17/wavefunction-collapse-algorithm/][This link]] has a simple explanation of Wavefunction Collapse in terms of constraint propagation.

The first wavefunction is a superposition of every possible results (akin to logic variables). Collapsing is taking one possible solution at random from all the possiblities. This choice has consequences that ripple out throught the rest of the solution space -> remove the solutions that become impossible conditional to the first choice you made. Repeat until everything is collapsed or until you've met a /contradiction/ (which makes collapse impossible). Start again if it fails.

Here we try to arrange pixels in an input image.

* Even simpler tiled model
* TODO Do on 1D line (sea-cost-land-cost-sea-sea-cost-land-land-coast)

Here I reproduce the example of [[https://robertheaton.com/2018/12/17/wavefunction-collapse-algorithm/][this article]].

In the /Even Simpler Tiled Model/ each tile is a single pixel of a single color. The rules specify how tiles can be placed one to another, and each rule is a tuple which designates two tiles, and how they can be adjacent to one another.

For instance, =("sea", "coast", "left")= specifies that a =sea= tile can be placed on the =left= of a =coast= tile.

#+begin_src python :session
tiles = (("s","s"), ("s","c"), ("c","s"), ("c","l"), ("l,c"), ("l,l"))
#+end_src

#+RESULTS:

We can have the program parse an input image and learn adjacencies from this. Apparently it also needs to count the number of times each tile appears.

#+begin_src python
example_img = [["s", "s", "s"], ["c", "c", "s"], ["l", "l", "c"]]
#+end_src

#+RESULTS:
: None

There is a notion of randomness here that we cannot really account for with (or can we?). Let us extract from the grid the relations between pixels that we'd like to constraint:

#+begin_src python :session
def horizontal_pairs(grid):
    length = height = len(grid)
    return [(grid[i][j], grid[i][j+1]) for i in range(height) for j in range(length-1)]

def vertical_pairs(grid):
    length = height = len(grid)
    return [(grid[i][j], grid[i+1][j]) for i in range(height-1) for j in range(length)]
#+end_src

#+RESULTS:


Let's say that the observed relations between grid elements are in the tuple =adjacency["left"]= then
the correponding goal is:

#+begin_src python :session :results output
from kanren import lall, lany, eq, vars

def generate(grid):
    return lall(
        lall(*(lany(*(eq(pair, adj) for adj in tiles)) for pair in horizontal_pairs(grid))),
        lall(*(lany(*(eq(pair, adj) for adj in tiles)) for pair in vertical_pairs(grid)))
    )

N = 20
grid = [vars(N) for _ in range(N)]

res = run(2, grid, generate(grid))
print(res[-1])
#+end_src


Ok so this is not great.


** TODO Plot the results each time
** TODO =RecursionError= is reached quite quickly on this example :noexport:

#+begin_src python :session
import pdb
from kanren import lall, lany, eq, vars, run

N = 1000
tiles = [0, 1]
all_vars = vars(N)

def generate(grid):
    return lall(
        ,*(lany(*(eq(pair, adj) for adj in tiles)) for pair in grid)
    )

pdb.set_trace()
res = run(1, all_vars, generate(all_vars))
print(res)
#+end_src

#+RESULTS:


* TODO Show the grid as it is being built (i.e. the miniKanren state being passed)
* TODO Show the stream of possible grids in a stream.
* TODO What is the influence of the original adjacency matrix?
In particular I would like to understand if more land on the original image will indeed lead to
more land on the final images. Maybe show the result as a function of % of land at the beginning. This is a central-ish feature of the Wavefunction Collapse.
* TODO Realtion between kanren and the entropy heuristic?

* Simple tiled model

Small number of small pre-defined tiles that define "rules" such as land, sea, coast, mountains. We choose the tile with the lowest entropy to collapse the wavefunction.

Initially the state is completely unobserved:

#+begin_src python
from kanren import vars

width = 10
height = 10

grid = vars(width * height)
#+end_src

Well actually, each pixel value is constrained to be one of the colors of the input bitmap

#+begin_src python
from kanren import lall, membero

BITMAP = (1, 2, 3, 4)
goal = lall(*tuple(membero(pixel, BITMAP) for pixel in grid))
#+end_src

From what I understand the resulting grid can only be a combination of the input tiles. Let's consider a simple grid with 1x2 tiles:

#+begin_src python
input_tile = [(1, 2), (1, 1), (2, 3)]
target_tiles = get_tiles(grid)  # extract tiles from the target grid
goal = lall(*tuple(lany(*tuple(membero(tile, model) for model in input_tiles)) for tile in target_tiles))
#+end_src

So really the complicated thing is extracting the tiles in the grid and how you do that. Manage symmetries is just applying transforms to the input.

#+begin_comment
Weighed decisions seem to be made via the minimum entropy criterion.
#+end_comment


* TODO miniKanren solution to the even simpler model :noexport:
* TODO Learn adjacency from image :noexport:
* TODO Print animation with all of miniKanren's solutions :noexport:
* TODO Program an interactive version? :noexport:
