#+TITLE: Solve sudokus with kanren
#+DATE: <2022-06-09 Thu>

I am reminded today of Peter Norvig's [[http://norvig.com/sudoku.html][blog post]] on solving every sudoku puzzle using constraint propagation and search. In this essay we will revisit the problem using the python implementation of [[http://minikanren.org/][miniKanren]], [[https://github.com/pythological/kanren/][kanren]], a domain-specific language for logic programming.

Peter's solution is /imperative/: we implement a series of procedures that will give us the missing values in a Sudoku puzzle. The /nature/ of the Sudoku, the rules, are hidden in this code. Here we will instead implement the rules of the Sudoku, i.e. the /relations/ that the units must respect and kanren will find the grids that respect these rules (given some hints) for us.

In plain english, a sudoku puzzle is a 9x9 grids such that:
- The rows are a permutation of the digits from 1 to 9;
- The columns are a permutation of the digits from 1 to 9;
- The squares are a permutation of the digits from 1 to 9;

* Solving sudoku vectors

Luckily =kanren= provides the =permuteo= function which when applied to two arguments produces a goal that states that these two arguments must be a permutation of one another. Let us illustrate on a simple example, a one-dimensional version of the sudoku if you wish. We will provide =karen= with a tuple of hints, and asks in returns the tuples which are permutations of the digits from 1 to 9 given the hints.

#+begin_src python :session :results output
from kanren import run, permuteo, var

NUMBERS = tuple(range(1, 10))

row = (0, 0, 0, 1, 4, 0, 0, 9, 8)
row_expr = tuple(r if r > 0 else var() for r in row)
res = run(2, row_expr, permuteo(row_expr, NUMBERS)) # we ask for two results satisfying the constraints
print(res)
#+end_src

#+RESULTS:
: ((2, 3, 5, 1, 4, 6, 7, 9, 8), (2, 3, 5, 1, 4, 7, 6, 9, 8))

Once we have described the constraints that must be followed, =kanren= does all the heavy lifting and finds the values that respect these constraints. We will come back to how =kanren= does that later, but for now let us take it as granted as solve sudokus!

* Solving sudoku grids

We store the sudoku grid as a 81-element list. Since constraints are defined on rows, columns and squares we need to be able to extract those units from a grid:

#+begin_src python :session :results silent
def get_rows(grid):
    """Return a grid's rows."""
    columns_idx = [[9 * i + j for j in range(9)] for i in range(9)]
    return tuple(tuple(grid[i] for i in column) for column in columns_idx)


def get_columns(grid):
    """Return a grid's columns."""
    rows_idx = [[i + 9 * j for j in range(9)] for i in range(9)]
    return tuple(tuple(grid[i] for i in row) for row in rows_idx)


def get_squares(grid):
    """Return a grid's squares."""
    squares_idx = [
        [9 * i + j for i in a for j in b]
        for a in ((0, 1, 2), (3, 4, 5), (6, 7, 8))
        for b in ((0, 1, 2), (3, 4, 5), (6, 7, 8))
    ]
    return tuple(tuple(grid[i] for i in square) for square in squares_idx)
#+end_src

We can now define the sudoku goal as the conjonction of permutation rule:

#+begin_src python :session :resuls
from kanren import permuteo, vars, lall, run

def sudoku(grid):
    """Define the Sudoku grid as a set on constraints on the rows, columns and squares.

    Parameter
    ---------
    grid
        A list that contains hints and logic variables ("unknown values").

    """
    rows = get_rows(grid)
    columns = get_columns(grid)
    squares = get_squares(grid)
    return lall(
        lall(*(permuteo(r, NUMBERS) for r in rows)),
        lall(*(permuteo(c, NUMBERS) for c in columns)),
        lall(*(permuteo(s, NUMBERS) for s in squares))
    )

#+end_src

And now theoretically solve any sudoku:

#+begin_src python :session :resuls
def solve_sudoku(grid):
    # Flatten the grid
    grid_flat = [int(elem) for row in grid for elem in row.split(" ")]
    assert len(grid_flat) == 81
    assert max(grid_flat) == 9

    grid_expr = tuple(val if val > 0 else var()  for val in grid_flat)
    res = run(1, grid_expr, sudoku(grid_expr))

    return res[0]
#+end_src

So far so good. =kanren= does all the heavy lifting for us, so our solution is more expressive than Peter's. Let us make sure that to solve a trivially easy problems where only a few values are missing:

#+begin_src python :session :results output
ridiculously_easy_puzzle = (
    "5 0 4 6 7 8 0 1 2",
    "6 0 2 1 0 5 3 4 8",
    "1 9 8 3 4 2 5 6 7",
    "8 5 9 7 0 1 4 2 3",
    "4 0 6 8 5 3 7 9 0",
    "7 1 3 9 2 4 8 5 6",
    "9 6 1 5 3 7 2 8 4",
    "2 8 7 4 1 9 6 3 5",
    "3 0 5 2 0 6 0 7 9",
)
result = solve_sudoku(ridiculously_easy_puzzle)
for i in range(9):
    print(result[9*i: 9*i+9])
#+end_src

#+RESULTS:
: (5, 3, 4, 6, 7, 8, 9, 1, 2)
: (6, 7, 2, 1, 9, 5, 3, 4, 8)
: (1, 9, 8, 3, 4, 2, 5, 6, 7)
: (8, 5, 9, 7, 6, 1, 4, 2, 3)
: (4, 2, 6, 8, 5, 3, 7, 9, 1)
: (7, 1, 3, 9, 2, 4, 8, 5, 6)
: (9, 6, 1, 5, 3, 7, 2, 8, 4)
: (2, 8, 7, 4, 1, 9, 6, 3, 5)
: (3, 4, 5, 2, 8, 6, 1, 7, 9)


But the computation hangs on the following (supposedly easy) problem:

#+begin_src python :session
easy_puzzle = (
    "0 0 3 0 2 0 6 0 0",
    "9 0 0 3 0 5 0 0 1",
    "0 0 1 8 0 6 4 0 0",
    "0 0 8 1 0 2 9 0 0",
    "7 0 0 0 0 0 0 0 8",
    "0 0 6 7 0 8 2 0 0",
    "0 0 2 6 0 9 5 0 0",
    "8 0 0 2 0 3 0 0 9",
    "0 0 5 0 1 0 3 0 0",
)
result = solve_sudoku(easy_puzzle)
for i in range(9):
    print(result[9*i: 9*i+9])
#+end_src

To understand why Peter's solution is orders of magnitude faster than kanren's search we need to understand how they differ.

* How Peter's solution works
* How kanren's search works
