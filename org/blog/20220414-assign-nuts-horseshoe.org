#+TITLE: Nested structures
#+DATE: <2022-04-15 Fri>

In the [[file:20220414-identify-horsehoe.org][last post]] we showed how we can identify a horseshoe prior in an aesara model graph. In the following we will provide a few improvements to the proposed solution, and set a prior on the number of trials =h=. Remember that the horseshoe prior is mathematically defined as:

#+begin_src latex :results raw :exports results
\begin{align*}
  \tau &\sim \operatorname{HalfCauchy}(0, 1)\\
  \lambda_{j} &\sim \operatorname{HalfCauchy}(0, 1)\quad j \in \left[1,\dots, k\right]\\
  \beta_{j} &\sim \operatorname{Normal}(0, \tau \;\lambda_{j})\quad j \in \left[1,\dots, k\right]\\
\end{align*}
#+end_src

#+RESULTS:
\begin{align*}
  \tau &\sim \operatorname{HalfCauchy}(0, 1)\\
  \lambda_{j} &\sim \operatorname{HalfCauchy}(0, 1)\quad j \in \left[1,\dots, k\right]\\
  \beta_{j} &\sim \operatorname{Normal}(0, \tau \;\lambda_{j})\quad j \in \left[1,\dots, k\right]\\
\end{align*}

However, the pattern that we used in the previous post only checks that the /structure/ is correct, but not that the correct distributions with the correct parameters are used. I thus propose to improve the design by defining a =unify_horseshoe= function that returns the random variables (=lambda_rv=, =tau_rv=) when the subgraph is identified, and =False= if unification is impossible.

#+begin_src python :session :results silent :exports both
from aesara.graph.unify import eval_if_etuple
from etuples import etuple, etuplize
from unification import unify, var

def unify_horseshoe(graph):
    horseshoe_1_lv, horseshoe_2_lv = var('horseshoe_1'), var('horsehoe_2')
    zero_lv = var('zero')
    horseshoe_pattern = etuple(
        etuplize(at.random.normal),
        var(),
        var(),
        var(),
        zero_lv,
        etuple(
            etuplize(at.mul),
            horseshoe_1_lv,
            horseshoe_2_lv)
    )

    s = unify(graph, horseshoe_pattern)
    if s is False:
        return False

    # Check that horseshoe_1 was unified with a half-cauchy distributed RV
    halfcauchy_1 = eval_if_etuple(s[horseshoe_1_lv])
    if halfcauchy_1.owner is None or not isinstance(
        halfcauchy_1.owner.op, type(at.random.halfcauchy)
    ):
         return False

    # Check that horseshoe_2 was unified with a half-cauchy distributed RV
    halfcauchy_2 = eval_if_etuple(s[horseshoe_2_lv])
    if halfcauchy_2.owner is None or not isinstance(
        halfcauchy_2.owner.op, type(at.random.halfcauchy)
    ):
        return False

    # Check that at least one of the RVs is a scalar
    if halfcauchy_1.type.shape == (1,):
        lmbda_rv = halfcauchy_2
        tau_rv = halfcauchy_1
    elif halfcauchy_2.type.shape == (1,):
        lmbda_rv = halfcauchy_1
        tau_rv = halfcauchy_2
    else:
        return false

    return (lmbda_rv, tau_rv)
#+end_src

Working again with the negative binomial regression:

#+begin_src python :session :results silent :exports code
import aesara.tensor as at

srng = at.random.RandomStream(0)

X_tt = at.matrix('X')

tau_rv = srng.halfcauchy(1, size=1)
lmbda_rv = srng.halfcauchy(1, size=10)
beta_rv = srng.normal(0, tau_rv * lmbda_rv)

eta = X_tt @ beta_rv
p = at.sigmoid(-eta)

h_rv = srng.poisson(10)

Y_rv = srng.nbinom(h_rv, p)
#+end_src

Again we check that we can unify the subgraph =beta_rv=:

#+begin_src python :session :results output :exports both
print(unify_horseshoe(beta_rv))
#+end_src

#+RESULTS:
: (halfcauchy_rv{0, (0, 0), floatX, False}.out, halfcauchy_rv{0, (0, 0), floatX, False}.out)

But not =Y_rv=

#+begin_src python :session :results output :exports both
print(unify_horseshoe(Y_rv))
#+end_src

#+RESULTS:
: False

The reason why we're trying to unify (sub)graphs with a horseshoe prior is that there are /Gibbs samplers/ that we can use to sample from the posterior distirbution of $lambda$ and $\tau$.

#+begin_src python :session :results silent :exports code
def step_horseshoe(lmbda, mu, beta):
    return lmbda, mu
#+end_src

So that:

#+begin_src python :session
import aesara

lambda_rv, tau_rv = unify_horseshoe(beta_rv)
outputs, updates = aesara.scan(
    fn=step_horseshoe,
    outputs=(lambda_rv, tau_rv),
    non_sequences=(beta_vv,)
)
#+end_src
